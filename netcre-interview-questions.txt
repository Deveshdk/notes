
	1. How does microservice implemented and what is orchestration and which design patter we can use for it.
	
		‚Ä¢ orchestration usually refers to automating the management, coordination, and organization of complex systems, services, or workflows.
		‚Ä¢ Eg. Container orchestration(Docker) 
		‚Ä¢ Managing containers across multiple machines
		‚Ä¢ Ensures container start stop scale and recover automatically.
		‚Ä¢ Example: Kubernetes
		‚Ä¢ Automation means automating one task.
		‚Ä¢ Orchestration means automating multiple task into a bigger process.
		‚Ä¢ Eg. Deploy app -> configure database -> start services -> scale when needed

	2. Which design pattern you used to migrate monolith to microservice architecture in your project?
		‚ÄúWe primarily used the Strangler Fig pattern for gradually migrating our monolith into microservices. We also introduced an API Gateway to manage routing between legacy and new services, and followed business capability decomposition to decide service boundaries. Over time, we moved towards database-per-service and used event-driven communication (Sagas) to handle cross-service workflows.‚Äù
		
		Strangler Fig pattern : 
		 
		‚óã Idea: Build new microservices around the edges of the monolith, and slowly "strangle" parts of the old system until the monolith is gone.
		‚óã Example: Instead of rewriting everything, move one module (say, User Management) into a microservice and route calls there. Over time, replace more modules.
	
		Decomposition pattern:
		
		‚Ä¢ By Business Capability ‚Äì each service owns one business function (like Payments, Orders, Inventory).
		‚Ä¢ By Subdomain (DDD) ‚Äì split by bounded contexts from Domain-Driven Design.
		
		API Gateway pattern:
		
		‚Ä¢ Acts as the single entry point for clients.
		‚Ä¢ Routes requests to either the monolith (for old functionality) or microservices (for new functionality).
		‚Ä¢ Helps avoid breaking the client when you‚Äôre halfway through migration.
		
		
		Database per service pattern:
		
		‚Ä¢ Monolith usually has one big shared database.
		‚Ä¢ In microservices, each service should own its own schema.
		‚Ä¢ Migration is usually step-by-step (sometimes starting with schema separation or change data capture (CDC)).
		
		Event Driven(Saga/ CQRS)
		
		‚Ä¢ When splitting services, you often need asynchronous communication.
		‚Ä¢ Saga pattern helps manage distributed transactions across services.
		‚Ä¢ CQRS (Command Query Responsibility Segregation) separates reads from writes, making it easier to scale and evolve services.
	

	3. If you are making 1million request call cal for one endpoint how do you scale it.

		‚Ä¢ Load Balancing
			¬ß Put a load balancer (NGINX, HAProxy, AWS ELB, GCP Load Balancer) in front.
			¬ß Distribute traffic across multiple app instances.
			¬ß Allows horizontal scaling (adding more servers/pods as needed).
		‚Ä¢ Horizontal Scaling(Stateless Service)
			¬ß Deploy multiple instances of your service (Kubernetes, Docker Swarm, ECS).
			¬ß Ensure your service is stateless (so any instance can handle any request).
			¬ß Use auto-scaling rules (scale out on CPU/RAM/requests per second).
			
		‚Ä¢ Caching
			¬ß Response Caching (CDN like Cloudflare, AWS CloudFront, Akamai) for static/less dynamic results.
			¬ß In-Memory Caching (Redis, Memcached) for frequently accessed data.
			¬ß Reduces DB load dramatically.
	
		‚óã Database Scaling
			¬ß For reads ‚Üí use read replicas (SQL) or sharding (NoSQL).
			¬ß For writes ‚Üí ensure batching, queueing, or event streaming (Kafka, RabbitMQ).
			¬ß Avoid making the DB the bottleneck.
			
		‚óã Asynchronous Processing
			¬ß If the endpoint triggers heavy tasks (e.g., report generation, ML inference), don‚Äôt block the request.
			¬ß Instead:
				‚ñ° Accept the request.
				‚ñ° Push the job to a message queue (Kafka, RabbitMQ, SQS).
				‚ñ° Process asynchronously.
				‚ñ° Return quickly with a 202 Accepted.
			
		‚óã Rate Limiting & Throttling
			¬ß Protect services with API Gateway rate limiting.
			¬ß Prevent a flood of requests from overwhelming the backend.
	
		‚óã Observability
			¬ß Add metrics (Prometheus, Grafana) to monitor RPS, latency, error rates.
			¬ß Enable logging + tracing (ELK, OpenTelemetry, Jaeger).
			¬ß Allows you to detect scaling issues early.
		
		
	4. How does indexing works and which algorithm it uses.
		‚óã When you create an index (e.g., CREATE INDEX idx_name ON Users(Email);)
			¬ß The DB builds a separate data structure (the index).
			¬ß The index stores the column values plus pointers to the actual rows in the table.
		‚óã When you query (SELECT * FROM Users WHERE Email = 'abc@test.com';)
			‚óã Instead of scanning the full table, the DB looks up the value in the index.
			‚óã The index quickly finds the row location (row ID, page number, etc.) and retrieves it.
	
	
	5. How higher order components work with example.

	6. How to store you credentials using hashing.
		Using hashing we encrypt our sensitive information into a hash map. Why can never be decrypted.
		It holds data integrity and keeps data safe.
		Algorithm that it uses SHA256 & SHA512

	7. What is middleware?

Middleware class use in real time
	We create extension methods for middleware to make them easier to use and provide a clean, fluent API. A middleware class contains a constructor with RequestDelegate next and an InvokeAsync(HttpContext context) method where we write pre-processing, call _next(context) to continue the pipeline, and then post-processing logic. For example, in my last project I created a Global Exception Handling middleware that caught unhandled exceptions, logged them, and returned a structured error response.‚Äù

	8. How to create a custom middleware its syntax.

		‚óã Logging Requests & Responses
		‚óã Global Exception Handling
		‚óã Adding Security Headers
		‚óã Rate Limiting / Throttling
		‚óã Custom Authentication Logic
	
	
	In Program.cs
	var builder = WebApplication.CreateBuilder(args);
	var app = builder.Build();
	
	app.UseGlobalExceptionHandling(); // üëà easy to add
	
	app.MapGet("/", () => throw new Exception("Boom!"));
	
	app.Run();
	
	
	// extension method
	public static class ExceptionHandlingMiddlewareExtensions
	{
	    public static IApplicationBuilder UseGlobalExceptionHandling(this IApplicationBuilder builder)
	    {
	        return builder.UseMiddleware<ExceptionHandlingMiddleware>();
	    }
	}
	
	
	
	public class ExceptionHandlingMiddleware
	{
	    private readonly RequestDelegate _next;
	    private readonly ILogger<ExceptionHandlingMiddleware> _logger;
	
	    public ExceptionHandlingMiddleware(RequestDelegate next, ILogger<ExceptionHandlingMiddleware> logger)
	    {
	        _next = next;
	        _logger = logger;
	    }
	
	    public async Task InvokeAsync(HttpContext context)
	    {
	        try
	        {
	            // Call next middleware in pipeline
	            await _next(context);
	        }
	        catch (Exception ex)
	        {
	            // Log the exception
	            _logger.LogError(ex, "Unhandled exception occurred");
	
	            // Return friendly error response
	            context.Response.StatusCode = 500;
	            context.Response.ContentType = "application/json";
	            await context.Response.WriteAsync(Newtonsoft.Json.JsonConvert.SerializeObject(new
	            {
	                StatusCode = 500,
	                Message = "An unexpected error occurred. Please try again later."
	            }));
	        }
	    }
	}




	9. What is Delegate?
	
	- A delegate in C# is a type-safe function pointer that holds a reference to a method with a specific signature. It allows us to pass methods as parameters, supports callbacks, multicasting, and is the foundation of events. For example, in ASP.NET Core, RequestDelegate is a delegate used in middleware to represent the next step in the pipeline.‚Äù
	‚Ä¢ A delegate is a type-safe function pointer in C#.
	‚Ä¢ It holds a reference to one or more methods with a specific signature and return type.
	‚Ä¢ Think of it as a way to pass methods as parameters.
	
	Eg . 
	public class Program
	{
	    public static void PrintMessage(string msg)
	    {
	        Console.WriteLine("Message: " + msg);
	    }
	
	    public static void Main()
	    {
	        MyDelegate del = new MyDelegate(PrintMessage); // assign method
	        del("Hello, World!"); // invoke delegate
	    }
	}


Why Do We Use Delegates?
	1. Flexibility (Pass Methods Around)
		‚óã Can pass methods as parameters (strategy pattern).
	2. Callback Mechanisms
		‚óã Example: Event handling, async operations.
	3. Multicasting
		‚óã One delegate can call multiple methods.
	4. Event Handling
		‚Ä¢ Delegates are the foundation of events in C#.


Types of Delegates
	1. Single-Cast Delegate ‚Üí points to one method.
	2. Multi-Cast Delegate ‚Üí can point to multiple methods (using +=).

using System;

namespace MulticastDelegateDemo
{
    // 1Ô∏è‚É£ Define a delegate type
    public delegate void NotifyDelegate(string message);

    class Program
    {
        // 2Ô∏è‚É£ Define some methods with the same signature
        static void SendEmail(string message)
        {
            Console.WriteLine($"üìß Email sent: {message}");
        }

        static void SendSMS(string message)
        {
            Console.WriteLine($"üì± SMS sent: {message}");
        }

        static void LogToFile(string message)
        {
            Console.WriteLine($"üóíÔ∏è Logged: {message}");
        }

        static void Main()
        {
            // 3Ô∏è‚É£ Create delegate instances
            NotifyDelegate notify1 = SendEmail;
            NotifyDelegate notify2 = SendSMS;
            NotifyDelegate notify3 = LogToFile;

            // 4Ô∏è‚É£ Combine them into a multicast delegate
            NotifyDelegate allNotifiers = notify1 + notify2 + notify3;

            // 5Ô∏è‚É£ Invoke it ‚Äî calls all three methods in order
            allNotifiers("System update completed!");

            // 6Ô∏è‚É£ You can remove one if you want
            allNotifiers -= SendSMS;

            Console.WriteLine("\nAfter removing SMS:");
            allNotifiers("System reboot scheduled.");
        }
    }
}


üß© Key Points
Concept	Explanation
+ / +=	Adds a method to the delegate‚Äôs invocation list
- / -=	Removes a method
Invocation order	Methods are called in the order they were added
Return values	If delegate returns a value, only the last method‚Äôs return value is used
Thread-safe	Delegate combination/removal operations are atomic



	11. How have you implemented solid principles in your last project.
	
		‚Ä¢ S ‚Üí Single Responsibility Principle (one class = one reason to change)
		‚Ä¢ O ‚Üí Open/Closed Principle (open for extension, closed for modification)
		‚Ä¢ L ‚Üí Liskov Substitution Principle (subtypes must work as base types)
		‚Ä¢ I ‚Üí Interface Segregation Principle (don‚Äôt force clients to depend on unused methods)
		‚Ä¢ D ‚Üí Dependency Inversion Principle (depend on abstractions, not concretions)


	üîπ 1. Liskov Substitution Principle (LSP)
	üëâ Focus: Correct inheritance hierarchy.
	üëâ Rule: Subtypes must be substitutable for their base types without breaking behavior.
	Example:
	
	public abstract class Bird
{
    public abstract void Move();
}
	public class Sparrow : Bird
{
    public override void Move() => Console.WriteLine("Sparrow flies");
}
	public class Ostrich : Bird
{
    public override void Move() => Console.WriteLine("Ostrich runs");
}
	‚úÖ Both Sparrow and Ostrich respect the Bird.Move() contract ‚Üí LSP followed.
	‚ùå If Ostrich threw NotImplementedException in Fly(), that would violate LSP.
	üîë In summary: LSP ensures inheritance doesn‚Äôt break polymorphism.
	
	üîπ 2. Dependency Inversion Principle (DIP)
	üëâ Focus: Correct dependencies between high-level and low-level modules.
	üëâ Rule: High-level modules should depend on abstractions, not concrete implementations.
	Example:
	‚ùå Bad (tight coupling):
	
	public class FileLogger
{
    public void Log(string message) => Console.WriteLine("File: " + message);
}
	public class OrderService
{
    private FileLogger _logger = new FileLogger(); // tightly coupled
	public void PlaceOrder()
    {
        _logger.Log("Order placed.");
    }
}
	‚úîÔ∏è Good (DIP applied with abstraction + DI):
	
	public interface ILogger
{
    void Log(string message);
}
	public class FileLogger : ILogger
{
    public void Log(string message) => Console.WriteLine("File: " + message);
}
	public class OrderService
{
    private readonly ILogger _logger;
    public OrderService(ILogger logger) => _logger = logger;
	public void PlaceOrder()
    {
        _logger.Log("Order placed.");
    }
}
	Now OrderService depends on abstraction (ILogger), not a specific class ‚Üí easier to extend (e.g., DatabaseLogger, ConsoleLogger).
	


	12. How many types of dependency injection how it works with example.
		‚Ä¢ Dependency Injection is a design pattern where an object (class) gets the objects it depends on (dependencies) from outside, instead of creating them itself.
		
		‚Ä¢ Use Transient ‚Üí when the service is lightweight & stateless.
		‚Ä¢ Use Scoped ‚Üí for business logic, repositories, DbContext.
		‚Ä¢ Use Singleton ‚Üí for heavy objects, configuration, caching, logging.


	13. What is async await.


	14. What is hashing and how it works.

	- Hashing = creating a fixed-size fingerprint of data.
	- We use it for fast lookups, data integrity, password storage, cryptography, and load balancing.
	- Same input ‚Üí always same hash.

	Fast Data Lookup (Hash Tables / Hash Maps)
		‚Ä¢ Hashing is the backbone of HashMap / Dictionary in programming.
		‚Ä¢ Instead of searching through all items (O(n)), the hash function maps a key directly to an index in constant time (O(1)).
	Data Integrity / Verification
		‚Ä¢ Hashing ensures data wasn‚Äôt changed during transmission or storage.
		‚Ä¢ Example: When you download a file, sites often provide an MD5 / SHA checksum. You hash your file ‚Üí if it matches ‚Üí file is intact.
	Password Storage (Security)
		‚Ä¢ We never store passwords in plain text. Instead:
			‚óã Password ‚Üí hash function ‚Üí hashed value stored in DB.
			‚óã When logging in, hash the entered password ‚Üí compare with stored hash.
		‚Ä¢ With salt + hashing, even same passwords generate different hashes.
	
	Load Balancing & Distributed Systems
		‚Ä¢ Hashing helps in consistent hashing, which decides how to distribute data across servers (used in CDNs, databases, distributed caches like Redis, Cassandra).
	
	Common Hashing Algorithms
		‚Ä¢ MD5 ‚Üí fast but broken (collisions).
		‚Ä¢ SHA-1 ‚Üí better but considered insecure now.
		‚Ä¢ SHA-256 / SHA-512 ‚Üí widely used, secure.
		‚Ä¢ bcrypt, scrypt, Argon2 ‚Üí designed specifically for password hashing.
	

Hashing Vs Encryption vs Encoding

	- Hashing: Like taking a fingerprint. You can verify identity, but can‚Äôt recreate the person from the fingerprint.
	- Encryption: Like locking data in a safe. Anyone with the right key can unlock it.
	- Encoding: Like translating text into Morse code or QR code. Anyone can decode it; it‚Äôs not meant to be secret.



14.
	
	
	
	üîπ Abstract vs Virtual in C#
	Feature	Abstract	Virtual
	Definition	A method declared in an abstract class without implementation.	A method in a base class with a default implementation, but can be overridden.
	Implementation Required?	Yes ‚Äì Must be overridden in a derived (non-abstract) class.	No ‚Äì Overriding is optional.
	Base Class Type	Only allowed inside an abstract class.	Can exist in any class (abstract or concrete).
	Polymorphism	Enforces polymorphism (child must provide its own implementation).	Supports polymorphism (child may override behavior).
	Default Implementation	‚ùå No default implementation.	‚úÖ Has a default implementation.
	Usage Scenario	Use when you want to force all derived classes to implement the method.	Use when you want to provide a default behavior but allow overriding if needed.
	




	15. Why Use Generics?
	‚Ä¢ Type Safety ‚Äì Errors are caught at compile-time instead of runtime.
	‚Ä¢ Reusability ‚Äì Write code once and use it with many types.
	‚Ä¢ Performance ‚Äì Avoids boxing/unboxing when working with value types.
	‚Ä¢ Clarity ‚Äì Makes APIs easier to use by explicitly declaring the type.

Syntax Basics
Generic Class

public class Box<T>
{
    private T _value;
public Box(T value)
    {
        _value = value;
    }
public T GetValue()
    {
        return _value;
    }
}
Usage:

var intBox = new Box<int>(123);
Console.WriteLine(intBox.GetValue()); // 123
var strBox = new Box<string>("Hello");
Console.WriteLine(strBox.GetValue()); // Hello

Generic Method

public class Utils
{
    public static void Print<T>(T item)
    {
        Console.WriteLine(item);
    }
}
Usage:

Utils.Print<int>(10);
Utils.Print("Generics are powerful!");

Generic Interface

public interface IRepository<T>
{
    void Add(T item);
    T Get(int id);
}

Constraints
You can restrict what kinds of types can be used with generics using constraints:

public class Factory<T> where T : new()
{
    public T Create()
    {
        return new T(); // works only if T has a parameterless constructor
    }
}
Common constraints:
	‚Ä¢ where T : struct ‚Üí value type only
	‚Ä¢ where T : class ‚Üí reference type only
	‚Ä¢ where T : new() ‚Üí must have a parameterless constructor
	‚Ä¢ where T : BaseClass ‚Üí must inherit from BaseClass
	‚Ä¢ where T : IInterface ‚Üí must implement IInterface

Built-in Generic Types in .NET
	‚Ä¢ Collections: List<T>, Dictionary<TKey, TValue>, Queue<T>, Stack<T>
	‚Ä¢ Delegates: Func<T>, Action<T>, Predicate<T>
	‚Ä¢ Nullable<T>: allows value types to be null

‚úÖ In short: Generics allow you to write flexible, reusable, and type-safe code in C#.




In SQL Server, a function is a stored program (like in programming languages) that performs a calculation, operation, or formatting, and then returns a value.

	15. üîπ Types of Functions in SQL Server
	1. System Functions
		‚óã Built-in by SQL Server.
		‚óã Examples:

SELECT GETDATE();         -- returns current date & time
SELECT LEN('Hello');      -- returns 5
SELECT UPPER('hello');    -- returns HELLO
	
	2. User-Defined Functions (UDFs)
	You can create your own functions.
	They must return a value and cannot change data (no INSERT/UPDATE/DELETE).
	There are two main types:
	a) Scalar Functions
		‚óã Return a single value (string, number, date, etc.).
	Example:
	
	CREATE FUNCTION dbo.GetFullName(@FirstName NVARCHAR(50), @LastName NVARCHAR(50))
RETURNS NVARCHAR(100)
AS
BEGIN
    RETURN @FirstName + ' ' + @LastName
END;
	Usage:
	
	SELECT dbo.GetFullName('John', 'Doe'); 
-- Output: John Doe
	
	b) Table-Valued Functions (TVFs)
		‚óã Return a table that you can use like a normal table in SELECT.
	Example:
	
	CREATE FUNCTION dbo.GetEmployeesByDept(@DeptId INT)
RETURNS TABLE
AS
RETURN
(
    SELECT Id, Name, Salary
    FROM Employees
    WHERE DepartmentId = @DeptId
);
	Usage:
	
	SELECT * FROM dbo.GetEmployeesByDept(2);
	
	üîë Key Points About Functions
		‚óã Must return a value (scalar or table).
		‚óã Cannot modify database state (unlike stored procedures).
		‚óã Can be reused inside queries (SELECT, WHERE, JOIN, etc.).
		‚óã Improve readability and reusability.
	
	
	
	üîπ Stored Procedure (SP)
		‚óã Does not have to return a value (but can return output parameters or result sets).
		‚óã Can modify data (INSERT, UPDATE, DELETE).
		‚óã More powerful ‚Üí can use transactions, exception handling, loops, etc.
		‚óã Cannot be used directly inside SELECT or WHERE.
	
	
	
	16. NOLOCK
	SELECT * 
	FROM Employees WITH (NOLOCK);
	This means:
	
	Your SELECT will not block other writes.
	
	Your query won‚Äôt wait if another transaction is inserting/updating data.
	
	üîπ Benefits of NOLOCK
	Faster reads (no blocking).
	
	Useful in reporting queries where you don‚Äôt want to wait for locks.
	
	üîπ Problems with NOLOCK
	It can cause dirty reads (reading uncommitted data). For example:
	
	You might read rows that are being inserted/updated but not committed yet.
	
	You might miss rows.
	
	You might read the same row twice.
	
	üîπ Dirty Read Example
	Transaction 1:
	
	sql
	Copy code
	BEGIN TRAN
	UPDATE Employees SET Salary = 5000 WHERE Id = 1;
	-- not committed yet
	Transaction 2 (with NOLOCK):
	
	sql
	Copy code
	SELECT Salary FROM Employees WITH (NOLOCK) WHERE Id = 1;
	You might see the updated salary (5000) before commit.
	
	If Transaction 1 rolls back, your query read a wrong value.
	
	üîë In Short
	NOLOCK = Read without locking / wait-free reads.
	
	Pros: faster, no blocking.
	
	Cons: risk of dirty reads, duplicate rows, missing rows.
	
	üëâ Best practice:
	Use NOLOCK only for reporting or analytics queries where absolute accuracy is not critical.
	

	16. So the 5 types of generics in C# are:

		Generic Classes
		
		Generic Methods
		
		Generic Interfaces
		
		Generic Delegates
		
		Generic Constraints


	17. Clustered vs non clustered

	18. A pipe is a utility function that lets you compose multiple functions together, passing the output of one as the input of the next.
		Example:
		
		const pipe = (...fns) => (value) =>
  fns.reduce((acc, fn) => fn(acc), value);‚Çπ
		// functions
const double = x => x * 2;
const square = x => x * x;
		// usage in React
const result = pipe(double, square)(3); // (3*2)=6 -> (6*6)=36
		





üîπ How to Force Garbage Collection
You can use the GC class from System:

using System;
class Program
{
    static void Main()
    {
        // Create some objects
        for (int i = 0; i < 1000; i++)
        {
            var obj = new object();
        }
// Force garbage collection
        GC.Collect();              // Forces garbage collection
        GC.WaitForPendingFinalizers(); // Waits for finalizers to run
        GC.Collect();              // Collect again to clean up finalized objects
Console.WriteLine("Garbage collection enforced.");
    }
}

üîπ What the Calls Do
	1. GC.Collect()
Forces immediate garbage collection for all generations (0, 1, 2).
	2. GC.WaitForPendingFinalizers()
Waits for finalizers (~destructors) of collected objects to finish running.
	3. (Optional) Another GC.Collect()
Cleans up objects that were waiting for finalization.

üîπ When (Not) to Use It
‚úÖ Good for:
	‚Ä¢ Unit tests (checking if finalizers are called).
	‚Ä¢ Memory profiling.
	‚Ä¢ Cleaning up before a critical operation (e.g., starting a heavy workload).
‚ùå Avoid in production code:
	‚Ä¢ It hurts performance (forcing GC may pause the application).
	‚Ä¢ The runtime already collects efficiently when needed.

‚úÖ In short:
You enforce garbage collection in C# with:

GC.Collect();
GC.WaitForPendingFinalizers();






üîπ What is Finalize?
	‚Ä¢ Finalize is a special method used by the Garbage Collector (GC) to clean up unmanaged resources before an object is destroyed.
	‚Ä¢ It is like a destructor in C++.
	‚Ä¢ You don‚Äôt call it directly ‚Äî the GC calls it automatically when it reclaims memory for an object.

üîπ How to Use Finalize
In C#, you declare a finalizer using the destructor syntax (~ClassName).
Example:

class MyClass
{
    // Finalizer
    ~MyClass()
    {
        Console.WriteLine("Finalize called - cleaning up resources!");
    }
}
When MyClass is no longer referenced and GC runs, Finalize is called before memory is reclaimed.

üîπ Important Points
	1. Not deterministic
You don‚Äôt know when (or if) Finalize will be called ‚Äî only when GC decides to collect.
	2. Performance overhead
Objects with finalizers take longer to collect, because GC puts them in a finalization queue first.
	3. Shouldn‚Äôt be used for managed resources
Managed resources (like string, List<T>, etc.) are handled by GC.
Finalize is only needed for unmanaged resources (file handles, database connections, sockets, etc.).

üîπ Best Practice ‚Üí Use IDisposable instead
Instead of relying on Finalize, C# recommends the Dispose Pattern with IDisposable.
This gives you deterministic cleanup.
Example:

class MyClass : IDisposable
{
    // Destructor (Finalizer)
    ~MyClass()
    {
        Dispose(false);
    }
public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this); // Prevent finalizer call
    }
protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            // Free managed resources
        }
        // Free unmanaged resources
    }
}

üîπ Summary
	‚Ä¢ Finalize = method called by GC before reclaiming an object.
	‚Ä¢ Implemented with ~ClassName() syntax.
	‚Ä¢ Used for unmanaged resource cleanup.
	‚Ä¢ Not deterministic ‚Üí you don‚Äôt control when it runs.
	‚Ä¢ Best practice: use IDisposable with Dispose() instead of relying only on finalizers.




Feature	Finalize	Dispose
Purpose	Cleanup unmanaged resources before GC destroys object.	Cleanup unmanaged (and optionally managed) resources deterministically.
How to implement	Destructor syntax: ~ClassName()	Implement IDisposable.Dispose()
Called by	Garbage Collector (automatically, at some unknown time).	User code explicitly (obj.Dispose()) or using statement.
Deterministic?	‚ùå No (you don‚Äôt know when GC will call it).	‚úÖ Yes (runs immediately when you call it).
Performance	Slower (object must go through finalization queue).	Faster (you control when cleanup happens).
Suppression	You can‚Äôt call Finalize directly.	Can suppress finalization via GC.SuppressFinalize(this).
Common Use Case	As a backup cleanup mechanism if Dispose is not called.	Main way to release unmanaged resources (files, DB connections, sockets).
Best Practice	Avoid unless absolutely needed.	Always implement if class holds unmanaged resources.



Difference between createRef and useRef

Feature	createRef	useRef
Component Type	Class components	Functional components
Ref Persistence	New ref object on every render	Same ref object across renders
Re-renders	Not reused	Persistent, does not trigger re-render
Use Cases	Mostly DOM access in class-based components	DOM access + storing mutable values (e.g., counters, timers) in functional components


Feature	string (Immutable)	StringBuilder (Mutable)
Mutability	Immutable (new object every change)	Mutable (changes in place)
Performance	Slow for many modifications	Fast for many modifications
Memory Usage	Higher (creates new copies)	Lower (reuses same buffer)
Namespace	System	System.Text
Best For	Small text, few changes	Large text, frequent changes



üîπ Struct vs Class
Feature	struct (Value Type)	class (Reference Type)
Storage	Stack (usually)	Heap
Copy Behavior	Copies entire value	Copies reference (points to same object)
Inheritance	No inheritance (only interfaces)	Supports full inheritance
Nullability	Cannot be null (unless Nullable<T> or T?)	Can be null
Performance	Better for small objects	Better for complex, large objects
Default Constructor	Auto-provided only	Can define your own


üîπ When to Use struct
Use a struct when:
	1. Small, lightweight data
		‚óã Example: Coordinates, sizes, colors.

public struct Point { public int X, Y; }
Point p = new Point { X = 10, Y = 20 };
	2. Immutability (often recommended for structs)
		‚óã Best if the data represents a single value (like DateTime, Guid, decimal).
	3. High performance scenarios
		‚óã Value types are stored on the stack (in most cases) ‚Üí faster allocation & deallocation.
		‚óã Example: In game development, structs are used for vectors, physics calculations where millions of small objects are created.
	4. No inheritance needed
		‚óã Structs can implement interfaces but cannot inherit classes.
		‚óã Use them when you don‚Äôt need polymorphism.


üîπ Stack Memory
	‚Ä¢ Stores:
		‚óã Value types (like int, float, struct),
		‚óã Method/function calls,
		‚óã Local variables (with fixed lifetime).
	‚Ä¢ Managed automatically with LIFO (Last In, First Out).
	‚Ä¢ Very fast allocation & deallocation.
	‚Ä¢ Scope-limited: once a method finishes, its stack frame is destroyed and variables are gone.
üëâ Example:

void Test()
{
    int x = 42;   // Stored in stack
    int y = x;    // Copy created, separate value
}
Here, x and y are on the stack, and y gets its own copy of the value.

üîπ Heap Memory
	‚Ä¢ Stores:
		‚óã Reference types (like class, object, string, arrays).
	‚Ä¢ Managed by the Garbage Collector (GC).
	‚Ä¢ More flexible, but slower than stack.
	‚Ä¢ Data stays in heap until no references point to it anymore, then GC cleans it up.
üëâ Example:

class Person { public string Name; }
void Test()
{
    Person p1 = new Person(); // Object stored in heap
    p1.Name = "Alice";
Person p2 = p1;  // Both p1 and p2 point to the same heap object
    p2.Name = "Bob";
Console.WriteLine(p1.Name); // "Bob"
}
Here:
	‚Ä¢ p1 and p2 are references (stack).
	‚Ä¢ The actual Person object is in the heap.

üîπ Key Differences
Feature	Stack Memory	Heap Memory
Type Stored	Value types, method calls, local variables	Reference types, objects, arrays
Allocation	Fast (LIFO)	Slower (managed by GC)
Lifetime	Until method ends (auto-cleaned)	Until no references remain (GC cleanup)
Size	Small, fixed size (limited by OS)	Larger, flexible
Access	Direct, fast	Indirect (via reference), slower
Example	int x = 10;	var obj = new Person();

üîπ Visual Example

struct Point { public int X, Y; }
class Person { public string Name; }
void Run()
{
    // Stack (value type)
    Point p1 = new Point { X = 5, Y = 10 }; // Stored in stack
// Heap (reference type)
    Person person1 = new Person { Name = "Alice" }; // Heap object
}
	‚Ä¢ p1 (struct) ‚Üí lives on stack.
	‚Ä¢ person1 (reference) ‚Üí reference lives on stack, actual Person object lives on heap.

‚úÖ In short:
	‚Ä¢ Stack = fast, small, stores value types & function calls, auto-cleared.
	‚Ä¢ Heap = larger, slower, stores reference types, managed by GC.



1. Clustered Index
	‚Ä¢ Definition: A clustered index determines the physical order of data in a table. The table‚Äôs rows are stored in the same order as the index.
	‚Ä¢ Key Points:
		‚óã There can be only one clustered index per table (because the data can be physically sorted in only one way).
		‚óã Accessing data via the clustered index is very fast because the data is already sorted.
		‚óã Often created on primary keys.
	‚Ä¢ Example: If you have a table of employees and a clustered index on EmployeeID, the rows will be physically stored in EmployeeID order.
Visual:

Clustered Index on EmployeeID
[101] -> [102] -> [103] -> [104]
(Data stored in the same order)

2. Non-Clustered Index
	‚Ä¢ Definition: A non-clustered index creates a separate structure from the table, which points to the actual data rows.
	‚Ä¢ Key Points:
		‚óã You can have many non-clustered indexes on a table.
		‚óã The data itself is not sorted in the order of the non-clustered index.
		‚óã Good for queries that filter or sort on columns other than the primary key.
	‚Ä¢ Example: If you have a non-clustered index on LastName, it contains the LastName and a pointer to the actual row.
Visual:

Non-Clustered Index on LastName
[Aaron] -> pointer to row 103
[Baker] -> pointer to row 101
[Clark] -> pointer to row 102
(Data stored elsewhere)

3. Key Differences at a Glance
Feature	Clustered Index	Non-Clustered Index
Physical Order of Data	Yes	No
Number per Table	1	Multiple
Storage	Data is stored in index order	Separate from data
Speed for Range Queries	Fast	Slower
Use Case	Primary keys, frequently sorted	Columns often searched/filtered

üí° Tip: Think of a clustered index as the table itself sorted, and a non-clustered index as a ‚Äútable of contents‚Äù pointing to the actual data.




1. Backend Pagination
Pagination is usually handled in the backend by limiting the number of results returned per request. Common approaches:
a) Using SQL LIMIT and OFFSET (MySQL/PostgreSQL)

-- Page 2, 10 items per page
SELECT * FROM users
ORDER BY id
LIMIT 10 OFFSET 10;
	‚Ä¢ LIMIT ‚Üí Number of items per page.
	‚Ä¢ OFFSET ‚Üí Number of items to skip (calculated as (page - 1) * pageSize).
Pros: Simple to implement.
Cons: Large offsets can be slow on huge datasets.

b) Using Keyset Pagination (Better for Large Tables)

-- Get 10 users after id 50
SELECT * FROM users
WHERE id > 50
ORDER BY id
LIMIT 10;
	‚Ä¢ Avoids OFFSET and is more efficient for large datasets.
	‚Ä¢ Requires a unique, sequential column (like id or timestamp).

c) Backend Response Format
The API should ideally return:

{
  "data": [ ...items... ],
  "page": 2,
  "pageSize": 10,
  "totalPages": 5,
  "totalItems": 45
}
This gives the frontend enough info to display pagination controls.

2. Frontend Pagination
a) Client-Side (All Data Loaded)
	‚Ä¢ Fetch all data once and paginate in the browser.
	‚Ä¢ Simple for small datasets.

const pageSize = 10;
const currentPage = 2;
const paginatedData = allData.slice((currentPage-1)*pageSize, currentPage*pageSize);
Pros: No repeated server requests.
Cons: Not suitable for large datasets.

b) Server-Side (Recommended for Large Data)
	‚Ä¢ Fetch only the required page from backend each time.

async function fetchPage(page) {
  const res = await fetch(`/api/users?page=${page}&pageSize=10`);
  const data = await res.json();
  return data;
}
	‚Ä¢ Update pagination controls based on totalPages from the response.

c) Frontend Controls
	‚Ä¢ Previous / Next buttons
	‚Ä¢ Page numbers (1, 2, 3‚Ä¶)
	‚Ä¢ Optional: Infinite scroll (load next page on scroll)

3. Best Practices
	1. Always limit number of items per page to avoid overloading the server.
	2. Use indexes on columns used for pagination (id, created_at) for speed.
	3. Return total count in API response if possible, for better UX.
	4. For huge datasets, prefer keyset pagination over OFFSET.




üîπ Types of Filters
ASP.NET Core provides several types of filters. Each runs at a different stage:
Filter Type	Purpose	Interface(s)	Example Use Case
Authorization Filters	Run first. Check if the user is authorized before entering controller/action.	IAuthorizationFilter, IAsyncAuthorizationFilter	Prevent unauthorized access.
Resource Filters	Run before model binding and after the rest of the pipeline. Useful for caching, short-circuiting requests.	IResourceFilter, IAsyncResourceFilter	Response caching, performance logging.
Action Filters	Run before and after action method execution.	IActionFilter, IAsyncActionFilter	Logging, input validation.
Exception Filters	Run if an unhandled exception occurs in an action or filter.	IExceptionFilter, IAsyncExceptionFilter	Global error handling for controllers.
Result Filters	Run before and after the execution of the action result (e.g., View rendering or JSON serialization).	IResultFilter, IAsyncResultFilter	Modifying response headers, formatting.


üîπ Example Scenarios
Use Case	Better With	Why
Logging every request/response	Middleware	Applies globally, before routing
Global error handling	Middleware	Catches everything, not just MVC
Serving static files	Middleware	Outside MVC
Authentication	Middleware	Needed before MVC runs
Authorization per action	Filter	Depends on action/controller attributes
Action parameter validation	Filter	Middleware can‚Äôt see action params
Modifying the returned IActionResult	Filter	Middleware can‚Äôt see MVC result objects
Caching per action result	Filter	Specific to action outputs

üîπ How They Work Together
Think of it like this:

Request
   ‚Üì
[Middleware pipeline: logging, auth, exception handler, etc.]
   ‚Üì
‚û°Ô∏è MVC Routing (request matches a controller/action)
   ‚Üì
[Filters pipeline: Authorization ‚Üí Resource ‚Üí Action ‚Üí Exception ‚Üí Result]
   ‚Üì
Controller Action executes
   ‚Üì
[Filters post-processing]
   ‚Üì
(Response generated)
   ‚Üì
[Middleware post-processing]
   ‚Üì
Response sent to client

‚úÖ In summary:
	‚Ä¢ Use middleware for global, framework-level concerns.
	‚Ä¢ Use filters for MVC-specific, action/controller-level logic.
	‚Ä¢ They don‚Äôt replace each other ‚Äî they complement each other at different levels of the pipeline.


üîπ What is Controller Short-Circuiting?
In ASP.NET Core MVC, controller short-circuiting means stopping the normal execution pipeline (filters ‚Üí controller action ‚Üí result) and directly producing a response earlier.
This prevents the controller action from running at all. It‚Äôs like saying:
	‚ÄúI already know what the response should be, so don‚Äôt bother executing the action method.‚Äù

üîπ Where Short-Circuiting Can Happen
	1. Authorization Filters
		‚óã If the user is not authorized, the filter can set a result (e.g., UnauthorizedResult) without calling the controller.
		‚óã Example: [Authorize] attribute.

public void OnAuthorization(AuthorizationFilterContext context)
{
    if (!context.HttpContext.User.Identity.IsAuthenticated)
    {
        context.Result = new UnauthorizedResult(); // Short-circuits
    }
}

‚ûù Controller action will not run.

	1. Resource Filters
		‚óã Run before model binding and before action filters.
		‚óã Can short-circuit if resource is already available (e.g., from cache).

public class CacheResourceFilter : IResourceFilter
{
    public void OnResourceExecuting(ResourceExecutingContext context)
    {
        // Suppose response is already cached
        context.Result = new ContentResult
        {
            Content = "Cached response"
        }; // Short-circuits controller
    }

public void OnResourceExecuted(ResourceExecutedContext context) { }
}

	1. Action Filters
		‚óã Less common, but possible.
		‚óã You can assign context.Result in OnActionExecuting to skip the controller.

public void OnActionExecuting(ActionExecutingContext context)
{
    if (!context.ModelState.IsValid)
    {
        context.Result = new BadRequestObjectResult(context.ModelState); 
        // Short-circuits controller
    }
}

üîπ How the Short-Circuit Works Internally
	‚Ä¢ All filters (Authorization ‚Üí Resource ‚Üí Action ‚Üí Exception ‚Üí Result) run inside the MVC pipeline.
	‚Ä¢ When a filter sets context.Result, the remaining pipeline is skipped:
		‚óã Controller action is not invoked.
		‚óã Later filters may or may not run, depending on type (e.g., Result Filters may still execute because they wrap result execution).

üîπ Example Flow with Short-Circuit
Normal flow:

Request ‚Üí Middleware ‚Üí Routing ‚Üí Auth Filter ‚Üí Resource Filter ‚Üí Action Filter ‚Üí Controller Action ‚Üí Result Filter ‚Üí Response
Short-circuit flow (e.g., user unauthorized):

Request ‚Üí Middleware ‚Üí Routing ‚Üí Auth Filter [sets UnauthorizedResult] ‚Üí Result Filter ‚Üí Response



üîπ Event
	‚Ä¢ An event is a wrapper around a delegate.
	‚Ä¢ It follows the publisher-subscriber pattern:
		‚óã Publisher defines an event.
		‚óã Subscribers attach event handlers (delegates).
		‚óã When the event is raised, all subscribers are notified.
‚ö†Ô∏è Events ensure encapsulation ‚Äî only the class that owns the event can raise it, while others can only subscribe/unsubscribe.
Example

public class Button
{
    // Define delegate type for event handlers
    public delegate void ClickHandler(string message);
// Define event based on delegate
    public event ClickHandler OnClick;
public void Click()
    {
        Console.WriteLine("Button clicked!");
        OnClick?.Invoke("User clicked the button"); // Raise event
    }
}
public class Program
{
    public static void Main()
    {
        var button = new Button();
// Subscribe event handlers
        button.OnClick += msg => Console.WriteLine($"Handler 1: {msg}");
        button.OnClick += msg => Console.WriteLine($"Handler 2: {msg}");
// Trigger event
        button.Click();
    }
}
Output:

Button clicked!
Handler 1: User clicked the button
Handler 2: User clicked the button

üîπ Delegate vs Event (Key Differences)
Aspect	Delegate	Event
Definition	Type-safe function pointer	Encapsulated delegate, used for notifications
Access	Can be invoked directly by anyone holding reference	Only the declaring class can invoke (Invoke()), others can only subscribe/unsubscribe
Usage	Callback, strategy pattern, passing methods around	Publish-subscribe pattern (button clicks, data changes, etc.)
Multicast	Can point to multiple methods	Same, but controlled (only publisher can raise)

1. Value Type (by semantics)
	‚Ä¢ Definition: A type where variables hold the actual data (value).
	‚Ä¢ Stored on the stack (in most cases, though sometimes inlined inside objects on the heap).
	‚Ä¢ Assignment ‚Üí makes a copy of the value.
	‚Ä¢ Equality (==) ‚Üí compares the values (structural comparison).
Examples:
	‚Ä¢ Built-in primitives: int, double, bool, char
	‚Ä¢ User-defined structs:

struct Point {
    public int X;
    public int Y;
}
Behavior:

int a = 5;
int b = a;  // b gets a copy
b = 10;
Console.WriteLine(a); // 5 (unchanged)

2. Reference Type (by semantics)
	‚Ä¢ Definition: A type where variables hold a reference (pointer) to the actual object, not the object itself.
	‚Ä¢ Always stored on the heap (reference stored on stack).
	‚Ä¢ Assignment ‚Üí copies the reference, so two variables can point to the same object.
	‚Ä¢ Equality (==) ‚Üí by default compares references (unless overridden with .Equals).
Examples:
	‚Ä¢ class types
	‚Ä¢ string (special case ‚Äî immutable but still a reference type)
	‚Ä¢ Arrays
	‚Ä¢ Delegates
Behavior:

class Person { public string Name; }
var p1 = new Person { Name = "Alice" };
var p2 = p1; // both point to the same object
p2.Name = "Bob";
Console.WriteLine(p1.Name); // Bob (changed)

3. ‚ÄúSemantic‚Äù Aspect
When people say ‚Äúsemantic value type‚Äù or ‚Äúsemantic reference type‚Äù, they usually mean:
	‚Ä¢ Semantic Value Type: The intended meaning is that equality and assignment should be based on values (not identity).
		‚óã Example: DateTime, decimal, Point.
		‚óã Even if you put two separate DateTime instances in memory, if they represent the same point in time, they are considered ‚Äúequal.‚Äù
	‚Ä¢ Semantic Reference Type: The intended meaning is that equality and assignment should be based on identity (reference).
		‚óã Example: Person, Car, Order.
		‚óã Two different Person objects with identical properties are still different people (different objects).

‚úÖ Quick Analogy
	‚Ä¢ Value type semantics: Like comparing two numbers on paper ‚Äî if both are ‚Äú5,‚Äù they‚Äôre equal.
	‚Ä¢ Reference type semantics: Like comparing two houses ‚Äî even if they look identical, they are not the same house unless they‚Äôre the same physical address.


Explain Api Versioning

üîë Ways API Versioning Works
1. URI Path Versioning (most common)
You include the version in the URL:

/api/v1/products
/api/v2/products
Pros ‚úÖ:
	‚Ä¢ Clear and explicit
	‚Ä¢ Easy for clients to understand
Cons ‚ùå:
	‚Ä¢ Can clutter routes if you have many versions
	‚Ä¢ URL changes even for minor updates

2. Query String Versioning
Clients specify version in a query parameter:

/api/products?api-version=1.0
/api/products?api-version=2.0
Pros ‚úÖ:
	‚Ä¢ Keeps base URL stable
	‚Ä¢ Easy to add programmatically
Cons ‚ùå:
	‚Ä¢ Not as visible in docs
	‚Ä¢ Caching proxies may treat it differently

3. Header Versioning
Version is passed in a custom header:

GET /api/products
api-version: 1.0
Pros ‚úÖ:
	‚Ä¢ Keeps URL clean
	‚Ä¢ Allows flexible version negotiation
Cons ‚ùå:
	‚Ä¢ Harder to test manually (e.g., in browser)
	‚Ä¢ Requires clients to set headers explicitly

4. Content Negotiation (Media Type Versioning)
Version is embedded in the Accept header:

Accept: application/json; version=1.0
Accept: application/vnd.myapi+json; version=2.0
Pros ‚úÖ:
	‚Ä¢ Elegant for REST purists
	‚Ä¢ Works well with content negotiation
Cons ‚ùå:
	‚Ä¢ More complex for clients to implement

‚öôÔ∏è API Versioning in ASP.NET Core
You can use the official package:

dotnet add package Microsoft.AspNetCore.Mvc.Versioning

Example setup in Program.cs:

builder.Services.AddApiVersioning(options =>
{
    options.AssumeDefaultVersionWhenUnspecified = true;
    options.DefaultApiVersion = new ApiVersion(1, 0);
    options.ReportApiVersions = true; // Adds API version headers to responses
});
Controller example:

[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
[ApiVersion("1.0")]
[ApiVersion("2.0")]
public class ProductsController : ControllerBase
{
    [HttpGet]
    public IActionResult GetV1() => Ok("Products v1");
[HttpGet, MapToApiVersion("2.0")]
    public IActionResult GetV2() => Ok("Products v2 with more details");
}

Strategy	Example	Pros	Cons	When to Use
URI Path Versioning	/api/v1/products	- Clear & explicit	- URL changes for every version	Public APIs, client-facing APIs where clarity matters
		- Easy to test & document	- Can clutter routes with many versions
		- Works well with caching
Query String Versioning	/api/products?api-version=1.0	- Keeps base URL stable	- Less visible in docs	Internal APIs, quick versioning without URL changes
		- Simple to add programmatically	- Some caching proxies ignore query params
Header Versioning	api-version: 1.0	- Clean URLs	- Harder to test in browser	Enterprise/internal APIs, APIs consumed by custom clients
		- Flexible version negotiation	- Requires client changes for headers
Media Type (Content Negotiation)	Accept: application/vnd.myapi+json; version=2.0	- RESTful & elegant	- More complex setup	APIs with multiple response formats, strict REST purists
		- Fits well with content negotiation	- Harder for casual consumers

‚Ä¢ GetV1() has no [MapToApiVersion], so it defaults to all declared versions (1.0 and 2.0).
‚Ä¢ GetV2() has [MapToApiVersion("2.0")], so it will only respond to version 2.0 requests.





Step By Step Deployment process

*‚ÄúIn my last project, we used GitHub for version control and Jenkins for CI/CD. Whenever we merged code into the main branch, Jenkins would trigger a build pipeline. The pipeline would install dependencies, run tests, and create a production build of the React app using npm run build. This build was then packaged into a Docker image and tagged with a unique version (build number or Git commit hash). The image was pushed to our container registry.
For deployment, we had a Jenkins job where we could choose the image tag, and Jenkins would update the dev Kubernetes environment using that image. Once the new version was deployed, we validated it in the dev environment. We also had a dashboard application that showed which image tags were currently deployed for each service across environments. This process ensured traceability and smooth deployments.
In short, the React app was built ‚Üí containerized ‚Üí pushed to registry ‚Üí and deployed via Jenkins into Kubernetes.‚Äù*


üîé Traceability Tools
1. Jira (by Atlassian)
	‚Ä¢ Used for requirement ‚Üí development ‚Üí testing ‚Üí deployment traceability.
	‚Ä¢ Links user stories, commits, builds, and test cases.
2. Azure DevOps
	‚Ä¢ Provides work item ‚Üí code ‚Üí build ‚Üí release traceability.
	‚Ä¢ Great for end-to-end DevOps pipelines with reporting dashboards.
3. GitHub / GitLab / Bitbucket Pipelines
	‚Ä¢ Commit history tied to issues/PRs.
	‚Ä¢ CI/CD pipelines linked to commits.
	‚Ä¢ Shows which commit triggered a build and deployment.
4. Jenkins with Plugins
	‚Ä¢ Not a traceability tool by itself, but with plugins (like Build Pipeline, Blue Ocean, or custom dashboards) it can provide traceability of builds ‚Üí artifacts ‚Üí deployments.
5. SonarQube
	‚Ä¢ Provides traceability in terms of code quality and security issues.
	‚Ä¢ Links issues to specific commits and branches.
6. Service Catalog / Deployment Dashboards (like the ‚ÄúMetro‚Äù app you mentioned)
	‚Ä¢ Internal dashboards that show:
		‚óã Which services are deployed
		‚óã Which image tags/versions are running
		‚óã In which environment (Dev, QA, Prod)
7. Test Management Tools (for QA traceability)
	‚Ä¢ TestRail, Zephyr, HP ALM ‚Üí link requirements ‚Üí test cases ‚Üí defects ‚Üí deployments.


‚ÄúTraceability tools help us know what version of code is deployed in which environment and link requirements to code and tests. Common tools include Jira for requirement-to-code traceability, Azure DevOps for full lifecycle tracking, GitHub/GitLab for commit and pipeline traceability, and SonarQube for code quality. In my last project, we also used an internal dashboard (like Metro) that showed all our services with their deployed image tags per environment, which made deployment traceability very easy.‚Äù



‚úÖ Why Docker is Preferred
	1. Portability ‚Üí ‚ÄúWorks on my machine‚Äù problem solved.
		‚óã Container runs the same everywhere (laptop, dev, cloud).
	2. Resource Efficiency
		‚óã Containers use fewer resources than VMs (no full OS per app).
	3. Faster Startup & Scaling
		‚óã Containers start in seconds vs minutes for VMs.
	4. Isolation
		‚óã Each app runs in its own container, avoiding dependency conflicts.
	5. DevOps & CI/CD Friendly
		‚óã Easy integration with Jenkins, Kubernetes, GitHub Actions.
	6. Microservices Ready
		‚óã Perfect for modern architectures where each microservice is containerized and deployed independently.




üîπ What is Blue-Green Deployment?
Blue-Green deployment is a release management strategy where you maintain two identical environments:
	‚Ä¢ Blue (current live/production) ‚Üí running the stable version.
	‚Ä¢ Green (new version) ‚Üí where you deploy and test the new release.
üëâ Once the green environment is tested and verified, you switch traffic (usually via load balancer, DNS, or API Gateway) from Blue to Green.

üîë Benefits
	‚Ä¢ Zero downtime deployment ‚Üí users don‚Äôt see outages.
	‚Ä¢ Easy rollback ‚Üí if something fails in Green, switch back to Blue.
	‚Ä¢ Safe testing in production-like environment.

üîπ How It Works in .NET / C# Context
Imagine you have an ASP.NET Core API or Blazor app:
	1. Step 1 ‚Äì Blue environment (say v1.0) is running in production.
	2. Step 2 ‚Äì Deploy new build (v2.0) to the Green environment.
	3. Step 3 ‚Äì Run smoke tests, integration tests, and verify logs/metrics on Green.
	4. Step 4 ‚Äì Switch the load balancer (e.g., Azure Front Door, AWS ALB, Nginx) to route traffic to Green.
	5. Step 5 ‚Äì Blue stays idle (but ready for rollback) until the next release.

üîπ Example in Practice (C# + ASP.NET Core + Azure)
	‚Ä¢ Your app is containerized in Docker.
	‚Ä¢ You run it in Azure App Service or Kubernetes.
	‚Ä¢ You deploy the new version (Green) while Blue is still serving requests.
	‚Ä¢ Once tests pass, you update the App Service slot swap (in Azure, slots = Blue/Green).
	‚Ä¢ Users are now on the new version instantly, no downtime.

üéØ Interview-Ready Answer
	‚ÄúBlue-Green deployment is a strategy where we keep two identical environments ‚Äî Blue (current production) and Green (new release). In .NET, for example, we can deploy a new ASP.NET Core build to the Green environment while Blue continues serving traffic. After testing, we switch traffic to Green, achieving zero downtime. If issues are found, we can roll back quickly by routing traffic back to Blue. This strategy reduces risk and ensures high availability.‚Äù




Generics : generics you can say is a type safe data type or placeholder of a data type.

Return Type: what type of value a method returns to a caller

Answer:
Feature	return	yield return
Use case	Ends method execution	Used in iterators to return sequence values
Works with	Any return type	Must return IEnumerable or IEnumerator
Example	return 5;	yield return i;
Example:

IEnumerable<int> GetNumbers()
{
    for (int i = 1; i <= 3; i++)
        yield return i;
}
Can you overload a method based only on return type? No, for overloading we need method name and parameter 
Can a method return a object: yes(including custom class, array, interface , delegates and object)
Can you return null? Yes, Only for nullable value type or reference type

Covariant return types: allows overridden method to return more derived type than the base method

Can a method return an interface or abstract class ? Yes, this allows flexibility and abstractions

What is the return type of async method?
	Task - if it returns no value
	Task<T> - if it returns a value
	Void - only for event handler

ValueTask<T>: it is the lightweight version of Task<T>, used for high performance scenarios

Can you use ref or out without a return type? Yes, 
Can you return a lambda or delegate from a method? Yes

 What is dynamic return type? Dynamic return type refers type checking until runtime. Complie-time checking is skipped so less-safe.


Sp vs Function

What are the challenges you faced during pipeline setup.

‚ÄúWhile setting up the CI/CD pipeline for our .NET / Node.js (or any tech stack) project in Azure DevOps (or Jenkins, GitHub Actions, etc.), we encountered several challenges.
Challenge 1 ‚Äì Configuration & Secrets Management:
Initially, each environment had its own hardcoded settings and credentials inside YAML files. This led to security issues and failed deployments when configs were out of sync.
Solution:
	‚Ä¢ Integrated Azure Key Vault and used variable groups for environment-specific settings.
	‚Ä¢ Implemented parameterized YAML templates for environment reuse.
	‚Ä¢ Applied RBAC and approvals before production release.
Challenge 2 ‚Äì Long Build Times:
Builds were taking over 25 minutes due to repetitive dependency downloads and serial stages.
Solution:
	‚Ä¢ Used pipeline caching for NuGet / npm dependencies.
	‚Ä¢ Configured parallel jobs for build, test, and code analysis.
	‚Ä¢ Introduced artifact retention policies and version tagging.
Challenge 3 ‚Äì Test Integration:
Test results weren‚Äôt reflected in the pipeline, making it hard to track failures.
Solution:
	‚Ä¢ Added a separate test stage with dotnet test and result publishing.
	‚Ä¢ Configured the pipeline to fail immediately on test errors.
Outcome:
	‚Ä¢ Reduced build time by ~60%.
	‚Ä¢ Improved reliability ‚Äî deployments became consistent and auditable.
	‚Ä¢ Strengthened security by removing hardcoded secrets.
Overall, I learned the value of designing pipelines as modular, parameterized, and environment-agnostic systems right from the start.‚Äù




What are the challenges you faced during migration to .net core.
What is micro frontend

What is deadlock avoidance?
Deadlock avoidance is a technique used in operating systems and multithreaded applications to ensure a system never enters a deadlock state.

3Ô∏è‚É£ Banker‚Äôs Algorithm (Most Famous Example)
Deadlock avoidance is most commonly implemented using the Banker‚Äôs Algorithm, which:
	‚Ä¢ Checks available resources
	‚Ä¢ Checks maximum possible demand of each process
	‚Ä¢ Grants resources only if the system remains safe

Safe state means there is atleast one sequence of execution where process can complete. No deadlock will appear.


Examples with c# to avoid deadlock in multithreading:

using System;
using System.Threading;

class Program
{
    private static readonly object lockA = new object();
    private static readonly object lockB = new object();

    static void Main()
    {
        Thread t1 = new Thread(Thread1Work);
        Thread t2 = new Thread(Thread2Work);

        t1.Start();
        t2.Start();

        t1.Join();
        t2.Join();

        Console.WriteLine("Completed without deadlock.");
    }

    static void Thread1Work()
    {
        // Always lock resources in alphabetical/numeric order ‚Üí A then B
        lock (lockA)
        {
            Console.WriteLine("Thread 1 locked A");
            Thread.Sleep(100);

            lock (lockB)
            {
                Console.WriteLine("Thread 1 locked B");
            }
        }
    }

    static void Thread2Work()
    {
        // Same order: A then B ‚Üí avoids deadlock
        lock (lockA)
        {
            Console.WriteLine("Thread 2 locked A");
            Thread.Sleep(100);

            lock (lockB)
            {
                Console.WriteLine("Thread 2 locked B");
            }
        }
    }
}

Why this avoids deadlock: beacause bith thread follow the same order, no thread block lockB first resulting no circular waiting can occur.

 In C#, we avoid deadlocks by enforcing a strict lock ordering rule.

How can we achieve multithreading in c#?
	1. We can create a new thread in main method and start it. Manually create a thread but not recommended for large application.
	2. Using threadpool(more efficient way)
		a. ThreadPool.QueueUserWorkItem(state =>{console.writeline("Running in threadpool thread");});
		b. Reuses system-managed threads
		c. Ideal for short background task
	3. Using Tasks
		a. Using System.Threading.Tasks
		b. Task.Run(() => { console.writeline("Task running on separate thread"); });
		c. Modern and recommended
		d. Supports async/await
		e. Handles scheduling automatically
	4. Async/await 
		async Task GetData()
		{
		    var result = await Task.Run(() => 
		    {
		        return "Running async task";
		    });
		
		    Console.WriteLine(result);
		}
		Keeps UI responsive.
		Generates background threads automatically
		Best for I/O operations.



What is probes? In Kubernates

Probes in kubernetes is health check done by kubelet to know whether a container is healthy, ready to receive traffic or should be restarted.

Types of probes:
	1. Liveness Probe
		a. Purpose: checks if your application is running or stuck.
		b. If it fails: Kubernetes restart the container
		c. Used for: detecting deadlock, unresponsive apps, frozen process 
	2. Readiness Probe
		a. Purpose: Checks if the application is ready to accept request
		b. It it fails: Kubernetes removes the pod from service load balancer untils its ready again
		c. Used for: Apps that need time to warm up, slow starting services, database connection inilialization.
	3. Startup Probe
		a. Purpose: Don‚Äôt perform liveness or readiness checks untill the app fully starts.
		b. If it fails: Container is restarted.


‚úÖ 1. .NET Core Application Probes
Program.cs sample endpoints
In a .NET API, you typically expose:

app.MapGet("/health", () => "OK");        // Liveness
app.MapGet("/ready", () => "READY");      // Readiness
app.MapGet("/startup", () => "STARTED");  // Startup
Kubernetes Deployment YAML

livenessProbe:
  httpGet:
    path: /health
    port: 80
  initialDelaySeconds: 10
  periodSeconds: 5
readinessProbe:
  httpGet:
    path: /ready
    port: 80
  initialDelaySeconds: 5
  periodSeconds: 3
startupProbe:
  httpGet:
    path: /startup
    port: 80
  failureThreshold: 30
  periodSeconds: 10
üëâ Why this is real-world
.NET Core apps sometimes take time to start (loading configs, EF migrations), so Startup Probe is extremely helpful.



What is Etype?
Etype in Active Directory means Encryption type.
Etype in C# means Enum type which represent a fixed set of named constants.


Minimal Api vs Controller
Contract package for testing
How will you deploy multi stage in docker
Copy in context of value type and reference type
What is blue green deployment
Semantic Value Type and Semantic Reference Type
How do you prevent attackers to write any html in your react form
What is micro frontend



