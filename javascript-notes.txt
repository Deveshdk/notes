//  Comparators $ Equality

    //  == only checks if the value is equal but === checks the value and the data type.
    //   ===  equal to
    //   !== not equal to
    //   > greater than
    //   < less than
    //  >= greater than or equal to
    //  <= less than or equal to
    //  && AND
    //  || OR 

Javascript is synchronous single-threaded language.
Javascript is loosely typed/weakly typed language. means it does not attaches its variable to a specific data type.
    means later the data type can be cahanged.

How Javascript Works :
    -   Whwnever we execute our code, a global execution context is created inside call stack with name anonymous.
    -   Execution context has 2 components. Memory and code.
    -   If any function is invoked, another execution context will be created with function name and will pushed into the call stack.
        And when execution of is completed, that execution context will popped out of the global context in call stack.
        And when all the execution is completed,global execution context will also be popped out and call stack will be empty.

Javascript has 2 phase.
    -   1st phase is Memory Execution : In this phase javascript scans the whole code and create a memory for all variable and function.
        Initially memory is created with undefined.
    -   2nd phase is Code Execution : In this phase execution happens.

Global space :
    -   Javascript creates 3 thing when execution starts.
    1. Global Execution context
    2. Global object i.e. window
    3. this
    At the start "this" will have the same value as window.
    eg. var x = 10;
        function b(){
            var a=5;
        }
        console.log(window.x);
        console.log(x);
        console.log(this.x);
        
        Output : 10,10,10 because window is in a global object, as well as this which has window in it.

Undefined vs Not-defined :
    -   Undefined is like a placeholder which is kept in a variable until in a code that variable is assigned to any value.
        But that variable should be present.
    -   Not defined means that variable is not present in the whole code. Means no memory creation for that variable.

Scope, scope & Lexical Environment :
    -   Lexical environment is created whenever an execution context is created.
    -   Lexical environment is the local memory and lexical environment of its parent.
    -   This whole chain of lexical enironment is called scope chain.
        eg. function a(){
                var b=10;
                c();
                function c(){
                    console.log(b);
                }
            }
            a();
        Output : 10;
                because c will be invoked, will try to log b, it will check its local memory first then if not found,
                it will check lexical environment of its parent(i.e. a).

Hoisting :
    -   Hoisting is a phenomenon in which you can access the variables or the functions before initializing it.
        eg1. console.log(x);
            getName();
            var x = 20;

            function getName () {
                console.log("Hello Javascript !");
            }
        Here we are accessing x and getname before initializing it.
        Explaination : In javascript before the code execution starts, memory creating is done for all variable and fn's.
            i.e memory for x and getName is already created.
            Now, for x it will print undefined if called before initialization.
            In case of getName, Output will be "Hello Javacript !" because you can access the function from anywhere in javascript
             until unless it's initialiazed in the whole code.

        eg2. var x = 20;
            function getName () {
                console.log("Hello Javascript !");
            }
            console.log(getName)

            In this case, memory is already created but the fn is not invoked yet so the output will be 
            Æ’ getName () {
            console.log("Hello Javascript !");
            }   

        eg3.console.log(getName)
            var getName = () => {
            console.log("Hello Javascript !");
            } 
            In this case getName is an arrow fn , so it will behave as a variable.
            So during memory  creation phase undefined will be stored.

        eg4. var getName = function (){
            console.log("Hello Javascript !");
            }
            In this case as well, getName will behave like a variable.

let vs const introduced in es6:
    -   




Map filter reduce :
    -   These functions is used to transform an array.

    Map :
        -   Map fn is used to transform an array and return a transformed array. or it is used to map each values in an array.
        -   const arr = [1,2,3,4,5];
            const output = arr.map(double);

            function double(x){
                return x*2;
            }

            function binary(x){
                return x.toString(2);
            }

    Filter :
        -   Filter fn is used to filter an array based on the condition.
        -   const arr = [3,5,7,9];
            const output = arr.filter(isOdd);

            function isOdd(x){
                return x%2;
            }
            function isEven(x){
                return x%2==0;
            }

    Reduce :
        -   Reduce fn takes all the values of an array and returns a single value out of them.
        -   It takes 2 parameter. one is a function which take acc and current, and other is the initialized value of acc.
        -   accumulator is like let count =0, or let sum =0; which will be updated or incremented ater iteraion. 
        -   accumilator must be initialiazed 
        -   const arr = [1,2,3,4,5];
            const sum = arr.reduce(function(acc,curr)=>{
                acc =acc + curr;
                return acc;
            },0);

        -   const findMax = arr.reduce(function(max,curr)=>{
                if(curr>max){
                    max=curr;
                }
                return max;
            },0);

        -   const users=[
            {fname:"Devesh" , lname : "kumar" , age :25},
            {fname : "mona", lname:"kaushiki",age:26},
            {fname:"motu", lname:"chumu", age:26},
            ]
            
            //find list of full name
            const output = users.map((x)=> x.fname +" "+ x.lanme);

            // how may users are with same age eg. {25:1,26:2}
            const output = users.reduce(function(acc,curr)=>{
                if(acc[curr.age]){
                    acc[curr.age] = ++ acc[curr.age];
                }
                else{
                    acc[curr.age]=1;
                }
                return acc;
            },{})

            // first name of all people whose age is <30
            aont output = users.filter(x=> x.age<30).map(x=> x.fname);


Higher Order function :
    -   A function that takes a fn as an argument and returns a fn.

Infinite curing:

Closure :

This keyword : 

Set interval :

Set timeout :

Debounce :

Throttling :

Event loop :

Arrow fn vs regular fn :

Optional chaining :

Event Bubbling : 

Spread Operator vs Rest Operator :

Pure function :

Merge to an array :

Copy of an object :

Promises :

Async await :

Es5 vs es6 :

Create a user token :

React fragment :

Callback :


