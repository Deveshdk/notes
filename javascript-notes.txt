//  Comparators $ Equality

    //  == only checks if the value is equal but === checks the value and the data type.
    //   ===  equal to
    //   !== not equal to
    //   > greater than
    //   < less than
    //  >= greater than or equal to
    //  <= less than or equal to
    //  && AND
    //  || OR 

Javascript is synchronous single-threaded language.
setTimeout, timer, local storage and document.getElementById or fetch() or console.log or addEventListener these are all web api and
these are all provided by browser in form of dom web api to the JS engine.
Javascript is loosely typed/weakly typed language. means it does not attaches its variable to a specific data type.
    means later the data type can be cahanged.

How Javascript Works :
    -   Whwnever we execute our code, a global execution context is created inside call stack with name anonymous.
    -   Execution context has 2 components. Memory and code.
    -   If any function is invoked, another execution context will be created with function name and will pushed into the call stack.
        And when execution of is completed, that execution context will popped out of the global context in call stack.
        And when all the execution is completed,global execution context will also be popped out and call stack will be empty.

Javascript has 2 phase.
    -   1st phase is Memory Execution : In this phase javascript scans the whole code and create a memory for all variable and function.
        Initially memory is created with undefined.
    -   2nd phase is Code Execution : In this phase execution happens.

Global space :
    -   Javascript creates 3 thing when execution starts.
    1. Global Execution context
    2. Global object i.e. window
    3. this
    At the start "this" will have the same value as window.
    eg. var x = 10;
        function b(){
            var a=5;
        }
        console.log(window.x);
        console.log(x);
        console.log(this.x);
        
        Output : 10,10,10 because window is in a global object, as well as this which has window in it.

Undefined vs Not-defined :
    -   Undefined is like a placeholder which is kept in a variable until in a code that variable is assigned to any value.
        But that variable should be present.
    -   Not defined means that variable is not present in the whole code. Means no memory creation for that variable.

Scope, scope & Lexical Environment :
    -   Lexical environment is created whenever an execution context is created.
    -   Lexical environment is the local memory and lexical environment of its parent.
    -   This whole chain of lexical enironment is called scope chain.
        eg. function a(){
                var b=10;
                c();
                function c(){
                    console.log(b);
                }
            }
            a();
        Output : 10;
                because c will be invoked, will try to log b, it will check its local memory first then if not found,
                it will check lexical environment of its parent(i.e. a).

Hoisting :
    -   Hoisting is a phenomenon in which you can access the variables or the functions before initializing it.
        eg1. console.log(x);
            getName();
            var x = 20;

            function getName () {
                console.log("Hello Javascript !");
            }
        Here we are accessing x and getname before initializing it.
        Explaination : In javascript before the code execution starts, memory creating is done for all variable and fn's.
            i.e memory for x and getName is already created.
            Now, for x it will print undefined if called before initialization.
            In case of getName, Output will be "Hello Javacript !" because you can access the function from anywhere in javascript
             until unless it's initialiazed in the whole code.

        eg2. var x = 20;
            function getName () {
                console.log("Hello Javascript !");
            }
            console.log(getName)

            In this case, memory is already created but the fn is not invoked yet so the output will be 
            Æ’ getName () {
            console.log("Hello Javascript !");
            }   

        eg3.console.log(getName)
            var getName = () => {
            console.log("Hello Javascript !");
            } 
            In this case getName is an arrow fn , so it will behave as a variable.
            So during memory  creation phase undefined will be stored.

        eg4. var getName = function (){
            console.log("Hello Javascript !");
            }
            In this case as well, getName will behave like a variable.

let & const introduced in es6:
Temporal Dead Zone :
    -   let and const can be hoisted and memory is also created for let and const but its not in global space rather in script space.
    -   

Block {}:
    -   Block is also kbnow as compound statement.
    -   A block is used to combine multiple js statement in one group.
    -   We combine mutiple statement in a block so can be used where javascript expects one statement.
    -   Each and every block has its own lexical scope. And if follows its own scope chain pattern.
Block Scope :
    -   What all variable and functions we can use inside a block.
        eg. {
                //compound statement
                var a=10;
                let b=20;
                const c=30;
                console.log(a);
                console.log(b);
                console.log(c);
            }
            console.log(a);
            console.log(b);
            console.log(c);
    -   let and const are block scope variable and once the block has been executed ,
        b and c will not be accessible while a was in global scope so "a" will be accessible.

Shadowing :
    -   If we have a same named variable outside the block, so it will shadow the variable.
    -   eg1. var a= 100;
            {
                //compound statement
                var a=10;
                let b=20;
                const c=30;
                console.log(a);
                console.log(b);
                console.log(c);
            }
        -   output will be : 10 20 30

        eg2. Output will be : 10 20 30 10  because both var a is pointing to the same global memory space.
            so "a" inside will shadow the outside the a variable.
            var a= 100;
            {
                //compound statement
                var a=10;
                let b=20;
                const c=30;
                console.log(a);
                console.log(b);
                console.log(c);
            }
            console.log(a);

        eg3. Output will be : 10 20 30 100 because now both "b" has different memory space. Inside b is inside block scope.
                outside b is in script space.
                Same happens in the case of const.
                And this happens in the case of function as well.
            let b= 100;
            {
                //compound statement
                var a=10;
                let b=20;
                const c=30;
                console.log(a);
                console.log(b);
                console.log(c);
            }
            console.log(b);

        eg4. Output will be 30 100
            const c= 100;
            function x(){
                //compound statement
                const c=30;
                console.log(c);
            }
            x();
            console.log(c);

    -   Illegal Shadowing :
        -   You cannot shadow var using let. but vice-versa is true.
            eg. let a=100;
                {
                    var a=10;
                } // Result in Syntax error.
                var a=100;
                {
                    let a=10;
                } // No error

Closure :
    -   Function which is bind together with its lexical parent forms a closure.
    -   Here b is bound with its local memory and variable of lexical parent. S0, it forms a closure.
        eg1. function c(){
                var a =10;
                function b(){
                    console.log(a);
                };
                b();
            };
            c();
    -   Function remembers its lexical scope even after returned.
    -   Here even if function b context is popped out after execution, but it still remembers its lexical scope and have memory.
        eg2. function c(){
                    var a =10;
                    function b(){
                        console.log(a);
                    };
                    return b;
                };
                var z = c();
                console.log(z);
                z();
        
        eg3.In this b will form 2 closure with c and s. Output: 10 900
        function s(){
                    var t=900;
                    function c(){
                        var a =10;
                        function b(){
                            console.log(a,t);
                        };
                        b();
                    };
                    c();
                };
                s();

    Uses of Closure :
        -   Module Design Pattern
        -   Currying
        -   Functions like once
        -   memoize
        -   maintaining state in async world
        -   setTimeouts
        -   Iterators

setTimeout & Closure :
    -   setTimeout takes a callback fn attaches the timer provided and stores in some other space and moves to the next line 
        and when that time has elapsed then js will put that fn in the call stack and executes it.
        eg. function x(){
                var i=10;
                setTimeout(function(){
                    console.log(i);
                },3000);
                console.log("Hello");
            }
            x(); /// Output : Hello 10

Counter with closure :
    -   Refer to js file.
    Disadvantage of Closure :
        -   There could be over consumption of memory because those variable are not garbage collected till the program expires.
        -   And if not handeled properly, there could be memory leak.
        Garbage Collector :
            -   It is like a program , whenever there is some unused variables which is not needed, it ceases/frees up the memory.
                since javascript is high level programming language. It is done by the JS engine.

Functions :
    -   Main Difference between function statement and function expression is hoisting.
    -   Function Statement :
        -   function a(){
                console.log(a);
            }
    -   Function Expression :
        -   var b = function(){
                console.log("b called");
            }
    -   Function Declaration :
        -   Function Declaration is also Function Statement.
    -   Anonymous Function :
        -   Function without a name is called anonymous function.
        -   Anonymous fn does not have its own identity.
        -   function () {

            }
    -   Named Function Declaration :
        -   var c = function abc(){
                console.log("b called");
            }

            abc(); // this will result in error because this fn abc was not created in global scope.
            It was created as a local variable.
    -   Parameters & Arguments :
        -    var b = function(param1, param2){    // param 1 and param2 is a parameter
                            console.log("b called");
                        }
            b(1,2); // 1 and 2 is an argument

    -   First Class Functions :
        -   The ability to use functions as values and can pass a fn inside a function or return a fn from a fn is called 
            first class function or first class citizens.
            eg. var a = function b(param1){
                    return (
                        console.log(b)
                    )
                }
                a(function(){

                })
    -   Arrow Functions introduced in es6:
        -   

Callback Function :
    -   When you pass a function inside another fn. You give the responsibility of calling a fn to another fn to call it some other time.
        This is callback fn.
    -   Using callback we can do the async task in javascript which is a single threded synchronous language.
        eg. setTimeout(function(){
                console.log("timer");
            },5000);

            function x(y){
                console.log("x");
                y();
            }
            x(function y(){
                console.log("y");
            })
    
    -   Event Listeners :
            eg. function attachEventListeners(){
                    let count = 0;
                    document.getElementById("clickMe").addEventListener("click",()=>{
                        console.log("Button Clicked" , ++count);
                    })
                }
                attachEventListeners();
        
        -   Garbage Collection & Remove EventListeners :
            -   EventListenerds are heavy and take memory because it forms a closure. And even if call stack is empty,
                program will not free up the extra memory. In order to do that we should remove our eventListeners.
                So, all this variables that was in the closure will be garbage collected.

Event loop :
    -   The purpose of event loop is to constantly monitor the call stack, microtask queue and the callback queue 
        if there is any callback fn present and 
        then it will create a executioj context for that callback fn and puts that callback fn inside the callstack.
        Refer to Callback.js

    -   Microtask Queue :
        -   Microtask queue has higher priority.
        -   First microtask queue will execute and then callback queue will execute.
        -   All the callback fn that comes with promises or mutation server will go in microtask queue.

Trust Issue with setTimeout :
    -   

Higher Order function :
    -   A function that takes a fn as an argument and returns a fn.
        eg. const radius = [1,2,3,4,5];

            const area = function (radius){
                return 2*Math.PI*radius*radius;
            }

            const calculate = function (radius,logic){
                const output = [];
                for(let i=0;i<radius.length;i++){
                    output.push(logic(radius[1]));
                }
                return output;
            }

            console.log(calculate(radius,area));

Map filter reduce :
    -   These functions is used to transform an array.

    Map :
        -   Map fn is used to transform an array and return a transformed array. or it is used to map each values in an array.
        -   const arr = [1,2,3,4,5];
            const output = arr.map(double);

            function double(x){
                return x*2;
            }

            function binary(x){
                return x.toString(2);
            }

    Filter :
        -   Filter fn is used to filter an array based on the condition.
        -   const arr = [3,5,7,9];
            const output = arr.filter(isOdd);

            function isOdd(x){
                return x%2;
            }
            function isEven(x){
                return x%2==0;
            }

    Reduce :
        -   Reduce fn takes all the values of an array and returns a single value out of them.
        -   It takes 2 parameter. one is a function which take acc and current, and other is the initialized value of acc.
        -   accumulator is like let count =0, or let sum =0; which will be updated or incremented ater iteraion. 
        -   accumilator must be initialiazed 
        -   const arr = [1,2,3,4,5];
            const sum = arr.reduce(function(acc,curr)=>{
                acc =acc + curr;
                return acc;
            },0);

        -   const findMax = arr.reduce(function(max,curr)=>{
                if(curr>max){
                    max=curr;
                }
                return max;
            },0);

        -   const users=[
            {fname:"Devesh" , lname : "kumar" , age :25},
            {fname : "mona", lname:"kaushiki",age:26},
            {fname:"motu", lname:"chumu", age:26},
            ]
            
            //find list of full name
            const output = users.map((x)=> x.fname +" "+ x.lanme);

            // how may users are with same age eg. {25:1,26:2}
            const output = users.reduce(function(acc,curr)=>{
                if(acc[curr.age]){
                    acc[curr.age] = ++ acc[curr.age];
                }
                else{
                    acc[curr.age]=1;
                }
                return acc;
            },{})

            // first name of all people whose age is <30
            aont output = users.filter(x=> x.age<30).map(x=> x.fname);

Promises :
    -   

Function Curring :
    -   

this keyword : 
    -   

Set interval :
    -   

Debounce :
    -   

Throttling :
    -   

Arrow fn vs regular fn :
    -   

Event Bubbling : 
    -   

Spread Operator vs Rest Operator :
    -   

Pure function :
    -   

Merge to an array :
    -   

Copy of an object :
    -   

Async await :
    -   

Es5 vs es6 :
    -   

Create a user token :
    -   

React fragment :
    -   

Prototype :
    -   
