//  Comparators $ Equality

    //  == only checks if the value is equal but === checks the value and the data type.
    //   ===  equal to
    //   !== not equal to
    //   > greater than
    //   < less than
    //  >= greater than or equal to
    //  <= less than or equal to
    //  && AND
    //  || OR 

Javascript is synchronous single-threaded language.
setTimeout, timer, local storage and document.getElementById or fetch() or console.log or addEventListener these are all web api and
these are all provided by browser in form of dom web api to the JS engine.
Javascript is loosely typed/weakly typed language. means it does not attaches its variable to a specific data type.
    means later the data type can be cahanged.

How Javascript Works :
    -   Whwnever we execute our code, a global execution context is created inside call stack with name anonymous.
    -   Execution context has 2 components. Memory and code.
    -   If any function is invoked, another execution context will be created with function name and will pushed into the call stack.
        And when execution of is completed, that execution context will popped out of the global context in call stack.
        And when all the execution is completed,global execution context will also be popped out and call stack will be empty.

Javascript has 2 phase.
    -   1st phase is Memory Execution : In this phase javascript scans the whole code and create a memory for all variable and function.
        Initially memory is created with undefined.
    -   2nd phase is Code Execution : In this phase execution happens.

Global space :
    -   Javascript creates 3 thing when execution starts.
    1. Global Execution context
    2. Global object i.e. window
    3. this
    At the start "this" will have the same value as window.
    eg. var x = 10;
        function b(){
            var a=5;
        }
        console.log(window.x);
        console.log(x);
        console.log(this.x);
        
        Output : 10,10,10 because window is in a global object, as well as this which has window in it.

Undefined vs Not-defined :
    -   Undefined is like a placeholder which is kept in a variable until in a code that variable is assigned to any value.
        But that variable should be present.
    -   Not defined means that variable is not present in the whole code. Means no memory creation for that variable.

Scope, scope & Lexical Environment :
    -   Lexical environment is created whenever an execution context is created.
    -   Lexical environment is the local memory and lexical environment of its parent.
    -   This whole chain of lexical enironment is called scope chain.
        eg. function a(){
                var b=10;
                c();
                function c(){
                    console.log(b);
                }
            }
            a();
        Output : 10;
                because c will be invoked, will try to log b, it will check its local memory first then if not found,
                it will check lexical environment of its parent(i.e. a).

Hoisting :
    -   Hoisting is a phenomenon in which you can access the variables or the functions before initializing it.
        eg1. console.log(x);
            getName();
            var x = 20;

            function getName () {
                console.log("Hello Javascript !");
            }
        Here we are accessing x and getname before initializing it.
        Explaination : In javascript before the code execution starts, memory creating is done for all variable and fn's.
            i.e memory for x and getName is already created.
            Now, for x it will print undefined if called before initialization.
            In case of getName, Output will be "Hello Javacript !" because you can access the function from anywhere in javascript
             until unless it's initialiazed in the whole code.

        eg2. var x = 20;
            function getName () {
                console.log("Hello Javascript !");
            }
            console.log(getName)

            In this case, memory is already created but the fn is not invoked yet so the output will be 
            Æ’ getName () {
            console.log("Hello Javascript !");
            }   

        eg3.console.log(getName)
            var getName = () => {
            console.log("Hello Javascript !");
            } 
            In this case getName is an arrow fn , so it will behave as a variable.
            So during memory  creation phase undefined will be stored.

        eg4. var getName = function (){
            console.log("Hello Javascript !");
            }
            In this case as well, getName will behave like a variable.

let & const introduced in es6:
Temporal Dead Zone :
    -   let and const can be hoisted and memory is also created for let and const but its not in global space rather in script space.
    -   

Block {}:
    -   Block is also kbnow as compound statement.
    -   A block is used to combine multiple js statement in one group.
    -   We combine mutiple statement in a block so can be used where javascript expects one statement.
    -   Each and every block has its own lexical scope. And if follows its own scope chain pattern.
Block Scope :
    -   What all variable and functions we can use inside a block.
        eg. {
                //compound statement
                var a=10;
                let b=20;
                const c=30;
                console.log(a);
                console.log(b);
                console.log(c);
            }
            console.log(a);
            console.log(b);
            console.log(c);
    -   let and const are block scope variable and once the block has been executed ,
        b and c will not be accessible while a was in global scope so "a" will be accessible.

Shadowing :
    -   If we have a same named variable outside the block, so it will shadow the variable.
    -   eg1. var a= 100;
            {
                //compound statement
                var a=10;
                let b=20;
                const c=30;
                console.log(a);
                console.log(b);
                console.log(c);
            }
        -   output will be : 10 20 30

        eg2. Output will be : 10 20 30 10  because both var a is pointing to the same global memory space.
            so "a" inside will shadow the outside the a variable.
            var a= 100;
            {
                //compound statement
                var a=10;
                let b=20;
                const c=30;
                console.log(a);
                console.log(b);
                console.log(c);
            }
            console.log(a);

        eg3. Output will be : 10 20 30 100 because now both "b" has different memory space. Inside b is inside block scope.
                outside b is in script space.
                Same happens in the case of const.
                And this happens in the case of function as well.
            let b= 100;
            {
                //compound statement
                var a=10;
                let b=20;
                const c=30;
                console.log(a);
                console.log(b);
                console.log(c);
            }
            console.log(b);

        eg4. Output will be 30 100
            const c= 100;
            function x(){
                //compound statement
                const c=30;
                console.log(c);
            }
            x();
            console.log(c);

    -   Illegal Shadowing :
        -   You cannot shadow var using let. but vice-versa is true.
            eg. let a=100;
                {
                    var a=10;
                } // Result in Syntax error.
                var a=100;
                {
                    let a=10;
                } // No error

Closure :
    -   Function which is bind together with its lexical parent forms a closure.
    -   Here b is bound with its local memory and variable of lexical parent. S0, it forms a closure.
        eg1. function c(){
                var a =10;
                function b(){
                    console.log(a);
                };
                b();
            };
            c();
    -   Function remembers its lexical scope even after returned.
    -   Here even if function b context is popped out after execution, but it still remembers its lexical scope and have memory.
        eg2. function c(){
                    var a =10;
                    function b(){
                        console.log(a);
                    };
                    return b;
                };
                var z = c();
                console.log(z);
                z();
        
        eg3.In this b will form 2 closure with c and s. Output: 10 900
        function s(){
                    var t=900;
                    function c(){
                        var a =10;
                        function b(){
                            console.log(a,t);
                        };
                        b();
                    };
                    c();
                };
                s();

    Uses of Closure :
        -   Module Design Pattern
        -   Currying
        -   Functions like once
        -   memoize
        -   maintaining state in async world
        -   setTimeouts
        -   Iterators

setTimeout & Closure :
    -   setTimeout takes a callback fn attaches the timer provided and stores in some other space and moves to the next line 
        and when that time has elapsed then js will put that fn in the call stack and executes it.
        eg. function x(){
                var i=10;
                setTimeout(function(){
                    console.log(i);
                },3000);
                console.log("Hello");
            }
            x(); /// Output : Hello 10

Counter with closure :
    -   Refer to js file.
    Disadvantage of Closure :
        -   There could be over consumption of memory because those variable are not garbage collected till the program expires.
        -   And if not handeled properly, there could be memory leak.
        Garbage Collector :
            -   It is like a program , whenever there is some unused variables which is not needed, it ceases/frees up the memory.
                since javascript is high level programming language. It is done by the JS engine.

Functions :
    -   Main Difference between function statement and function expression is hoisting.
    -   Function Statement :
        -   function a(){
                console.log(a);
            }
    -   Function Expression :
        -   var b = function(){
                console.log("b called");
            }
    -   Function Declaration :
        -   Function Declaration is also Function Statement.
    -   Anonymous Function :
        -   Function without a name is called anonymous function.
        -   Anonymous fn does not have its own identity.
        -   function () {

            }
    -   Named Function Declaration :
        -   var c = function abc(){
                console.log("b called");
            }

            abc(); // this will result in error because this fn abc was not created in global scope.
            It was created as a local variable.
    -   Parameters & Arguments :
        -    var b = function(param1, param2){    // param 1 and param2 is a parameter
                            console.log("b called");
                        }
            b(1,2); // 1 and 2 is an argument

    -   First Class Functions :
        -   The ability to use functions as values and can pass a fn inside a function or return a fn from a fn is called 
            first class function or first class citizens.
            eg. var a = function b(param1){
                    return (
                        console.log(b)
                    )
                }
                a(function(){

                })
    -   Arrow Functions introduced in es6:
        -   

Callback Function :
    -   When you pass a function inside another fn. You give the responsibility of calling a fn to another fn to call it some other time.
        This is callback fn.
    -   Using callback we can do the async task in javascript which is a single threded synchronous language.
        eg. setTimeout(function(){
                console.log("timer");
            },5000);

            function x(y){
                console.log("x");
                y();
            }
            x(function y(){
                console.log("y");
            })
    
    -   Event Listeners :
            eg. function attachEventListeners(){
                    let count = 0;
                    document.getElementById("clickMe").addEventListener("click",()=>{
                        console.log("Button Clicked" , ++count);
                    })
                }
                attachEventListeners();
        
        -   Garbage Collection & Remove EventListeners :
            -   EventListenerds are heavy and take memory because it forms a closure. And even if call stack is empty,
                program will not free up the extra memory. In order to do that we should remove our eventListeners.
                So, all this variables that was in the closure will be garbage collected.

Event loop :
    -   The purpose of event loop is to constantly monitor the call stack, microtask queue and the callback queue 
        if there is any callback fn present and 
        then it will create a executioj context for that callback fn and puts that callback fn inside the callstack.
        Refer to Callback.js

    -   Microtask Queue :
        -   Microtask queue has higher priority.
        -   First microtask queue will execute and then callback queue will execute.
        -   All the callback fn that comes with promises or mutation server will go in microtask queue.

Trust Issue with setTimeout :
    -   

Higher Order function :
    -   A function that takes a fn as an argument and returns a fn.
        eg. const radius = [1,2,3,4,5];

            const area = function (radius){
                return 2*Math.PI*radius*radius;
            }

            const calculate = function (radius,logic){
                const output = [];
                for(let i=0;i<radius.length;i++){
                    output.push(logic(radius[1]));
                }
                return output;
            }

            console.log(calculate(radius,area));

Map filter reduce :
    -   These functions is used to transform an array.

    Map :
        -   Map fn is used to transform an array and return a transformed array. or it is used to map each values in an array.
        -   const arr = [1,2,3,4,5];
            const output = arr.map(double);

            function double(x){
                return x*2;
            }

            function binary(x){
                return x.toString(2);
            }

    Filter :
        -   Filter fn is used to filter an array based on the condition.
        -   const arr = [3,5,7,9];
            const output = arr.filter(isOdd);

            function isOdd(x){
                return x%2;
            }
            function isEven(x){
                return x%2==0;
            }

    Reduce :
        -   Reduce fn takes all the values of an array and returns a single value out of them.
        -   It takes 2 parameter. one is a function which take acc and current, and other is the initialized value of acc.
        -   accumulator is like let count =0, or let sum =0; which will be updated or incremented ater iteraion. 
        -   accumilator must be initialiazed 
        -   const arr = [1,2,3,4,5];
            const sum = arr.reduce(function(acc,curr)=>{
                acc =acc + curr;
                return acc;
            },0);

        -   const findMax = arr.reduce(function(max,curr)=>{
                if(curr>max){
                    max=curr;
                }
                return max;
            },0);

        -   const users=[
            {fname:"Devesh" , lname : "kumar" , age :25},
            {fname : "mona", lname:"kaushiki",age:26},
            {fname:"motu", lname:"chumu", age:26},
            ]
            
            //find list of full name
            const output = users.map((x)=> x.fname +" "+ x.lanme);

            // how may users are with same age eg. {25:1,26:2}
            const output = users.reduce(function(acc,curr)=>{
                if(acc[curr.age]){
                    acc[curr.age] = ++ acc[curr.age];
                }
                else{
                    acc[curr.age]=1;
                }
                return acc;
            },{})

            // first name of all people whose age is <30
            aont output = users.filter(x=> x.age<30).map(x=> x.fname);

Callback hell or Pyramid of Doom:
    -   One callback inside another callback inside callback or a lot of nested callback.
Inversion of Control :
    -   We loose control of our program because we passed that callback fn into another fn and now we have given the control of 
        that f to some other fn.And now we don't know whether that fn will ever execute our callback or not.

Promise :
    -   Promise is an object that represt an eventful completion or failure of an asynchronous event.
    -   PromiseState represents the current state of a promise.Promise has 3 state. Initially it is in pending state.
        Pending, Fulfilled & Rejected.
    -   Promise can only be resolved once and promise obejcts are immutable too so we can just pass it here n there in our code.
    -   We can attach a handler/callbackfn with .then
    -   So promise resolves our concern over Inversion of control.
    -   eg. const GITHUB_API = "https://github.com/Deveshdk?tab=repositories";
            const user= fetch(GITHUB_API);
            console.log(user);
            // now we attach a callback fn
            user.then(function(data){
            })
            -   And we attach n number of callback functions to our promise using .then
            -   This resolves our concern of callback hell using promise chaining.
                eg. createOrder(cart)
                    .then(function(orderId){
                        return proceedToPayment(orderId)
                    })
                    .then(function(paymentInfo){
                        return orderSummary(paymentInfo)
                    })
                    .then(function(paymentInfo) {
                        returnwalletUpdate(paymentInfo)
                    });
    -   How to create a promise and promise chaining with example. eg. createPromise.js

Promise Api :
    -   Promise.all() / fail fast:
        -   It takes an array of promise. eg. promise.all = [p1,p2,p3]
        -   It will make 3 parallel api call.
        -   Case1 : If all gets success.
                Output : [val1, val2, val3] and output will wait for all of them to finish(time taken).
            Case2 :  If any of these promise get rejected.
                Output : As soon as any of these promise gets rejected, promise.all will throw an error.(immediately)
                        And the output will give the same error as the rejected one.
                        It will not even wait other promise to be resolved or rejected.
                        You cannot cancel the promise in between.

    -   Promise.allSettled() :
        -   Case 1 : If all gets resolved. 
                Output : [val1,val2,val3] and output will wait for all of them to finish(time taken). same as promise.all in success.
            Case 2 : If p2 get rejected. It will still wait for all promise to get settled/completed.
                Output : [val1,err2,val3] The output will always be an array and with the same number of promises.
    
    -   Promise.race() :
        -   It will give you the value of 1st settled promise. 
        -   Output will be the result of 1st settled promise either value if resolved or error if rejected.
    
    -   Promise.any() :
        -   It will wait for 1st successful/fulfilled/resolved promise.
        -   If all the promises gets rejected, Output will be aggregated error. [err1,err2,err3]
        -   THis is how we catch/handle an Aggregate error. eg. console.log(err.errors);

Async/ await :
    -   Async will always returns a promise. but if you return a value, then the function will wrap that value in a promise and 
        then return a promise.
    -   Async and await is used to handle promises.
    -   In async / await , we dont have to do the promise chaining and it is more readable.
    -   Await is keyword that can only be used inside an async fn and it resolves the promise. you always write it infornt of a promise.
        eg. const p1 = new Promise(function(resolve,reject){
                setTimeout(()=>{
                    resolve("Promise resolved value");
                },5000);
            })

            const p2 = new Promise(function(resolve,reject){
                setTimeout(()=>{
                    resolve("Promise resolved value");
                },10000);
            })

            // after async await
            async function handlePromise(){
                console.log("hello world");
                const val1 = await p1;
                console.log("Hello1");
                console.log(val1);
                const val2 = await p2;
                console.log("Hello2");
                console.log(val2);
            }
            handlePromise();
            -   When the execution starts, handlePromise will be added in the call stack , and when it will find await p1
                handlePromise will move out of the call stack and will not block the main thread.
                now once p1 is resolved after 5 sec then handlePromise will again be added in the call stack and
                it will start it's execution 
                from where it left and then again when it will find await p2 ,
                handlePromise will again suspend the execution and move out of 
                the call stack and when p2 is resolved , then handlePromnise will again be added in the call stack and will start its 
                execution from where it left.

    Error Handling :
        -   using try and catch.

Function Curring :
    -   Currying is a functional programming concept where a function with multiple arguments is transformed into a series of functions,
        each taking a single argument.
        It allows you to create more specialized functions by partially applying arguments to a function, resulting in a new function.
    -   Currying can be achieved by using bind and by using closure.
    -   bind is used to make a copy of a function by passing partial arguments to the function.
        eg. function multiply(x,y){
                console.log( x*y);
            }
            let multiplyByTwo = multiply.bind(this,2);
            multiplyByTwo(3); or we can pass it different way as well . in below

            let multiplyByTwo = multiply.bind(this,2,3);
            multiplyByTwo(); or we can pass it in another way as well. in below

            let multiplyByTwo = multiply.bind(this);
            multiplyByTwo(2,3);

        eg2. Using closure
            function multiply(x){
                return function(y){
                    console.log(x*y);
                }
            }
            let multiplyByThree = multiply(10);
            multiplyByThree(2);

this keyword : 
    -   

Set interval :
    -   

Debounce :
    -   

Throttling :
    -   

Arrow fn vs regular fn :
    -   

Event Bubbling : 
    -   

Spread Operator vs Rest Operator :
    -   

Pure function :
    -   

Merge to an array :
    -   

Copy of an object :
    -   

Async await :
    -   

Es5 vs es6 :
    -   

Create a user token :
    -   

React Fragment <></> or <React.Fragment></React.Fragment>: 

Prototype & prototypal inheritence :
    -   Whenever we create any javascript object, functions or variable , JS put some hidden properties and methods into an object
        and attaches it to our object. 
    -   Prototype is an object that attaches to our object with some hidden properties and methods.
    -   
        let arr = ["dev","mona"]
        function fun(){

        }
    -   In order to see that object that JS attaches we can simply do like f.__proto__ or arr.__proto__
    -   arr.__proto__ is Array.Prototype => arr.__proto__.__proto__ is Object.prototye => arr.__proto__.__proto__.__proto__ is null.
    -   fun.__proto__ is Function.prototype => fun.__proto__.__proto__ is Object.prototype ==>fun.__proto__.__proto__.__proto__ is null.
    -   This is called prototype chain.

    Protoypal inheritence :
    -   If we attach any object1 to another object2 prototype, we will be able to use object1 properties.
    -   In case of function if we bind any fn to Function.protype, we will be able to use that fn in all other fn using fn.__proto__.methodName
        -   eg. let object = {
                    name : "Devesh",
                    age : 28,
                    city: "Purnia",
                    getIntro: function(){
                        console.log("My name is"+ this.name + "And my age is " + this.age);
                    }
                }

                let object2 = {
                    name : "Mona",
                    age :29
                }
                object2.__proto__ = object;
                console.log("My name is "+ object2.name + " and i am from "+ object2.city);

                Function.prototype.mybind = function(){
                    console.log("I am Heman!!");
                }

                function fun(){
                    fun.__proto__.mybind();
                }

Deep copy of an Object :
    -   Making a deep copy of an object involves creating a new object with the same structure and values as the original object,
        while ensuring that nested objects and arrays are also copied rather than referenced.

        Approach 1 : this does not work with object that contains fn or undefined or symbols.
            const originalObject = { a: 1, b: { c: 2 } };
            const deepCopy = JSON.parse(JSON.stringify(originalObject));
            console.log(deepCopy);
        
        Approach 2 : Using a deep copy fn.
            function deepCopy(obj) {
                if (obj === null || typeof obj !== 'object') {
                    return obj;
                }

                if (Array.isArray(obj)) {
                    return obj.map(deepCopy);
                }

                const copy = {};
                for (const key in obj) {
                    if (obj.hasOwnProperty(key)) {
                    copy[key] = deepCopy(obj[key]);
                    }
                }

                return copy;
            }

            const originalObject = { a: 1, b: { c: 2 } };
            const deepCopy = deepCopy(originalObject);
            console.log(deepCopy);

        Apporach 3 : Using library lodash and .cloneDeep method
            const _ = require('lodash');
            const originalObject = { a: 1, b: { c: 2 } };
            const deepCopy = _.cloneDeep(originalObject);
            console.log(deepCopy);

Copy of an Object :
    -   We can make a copy of an object in 2 ways :
        -   Shallow copy
            -   Using Spread operator (...) :
                eg. const originalObject = { a: 1, b: { c: 2 } };
                    const shallowCopy = { ...originalObject };
            -   Using Object.assign() :
                eg. const originalObject = { a: 1, b: { c: 2 } };
                    const shallowCopy = Object.assign({}, originalObject);
        -   Deep copy using deep function or library or JSON.parse & JSON.stringify.

Merge to an array ;
    -   Concatenation (shallow copy) : It will create a new array.
        eg. array1.concat(array2);
    -   Spread Operator (shallow copy) : It will create new array.
        eg. const mergedArray = [...array1, ...array2];
    
    -   Array.push() : Mutates the original array.
        eg. array1.push(...array2);
    -   Array.unshift() : Mutates the original array. It adds elements to the beginning of an array.
        eg. array2.unshift(...array1);

Pure fn vs Impure fn :
    -   Pure fn :
        eg. function add(a, b) {
                return a + b;
            }
        -   with same imput, always same output.
        -   Immutable data
        -   Does not rely on external state.
        -   Does not modify the imput parameter.
        -   Does not modify variable outside its scope.
        -   Behaviour is predictabe and isolated , so straightforward to test.
        -   No hidden dependency.
    
    -   Impure fn :
        eg. let total = 0;
            function impureAdd(a) {
            total += a;
            return total;
            }
        -   relies on external state and modifies it.

Spread and Rest Operator :
    -   Both denoted by (...)
    -   Spread Operator :
        -   Used to make a shallow copy of an array or concatenate array.
        -   Used to make a shallow copy of an object or to merge an object.
    -   Rest Operator :
        -   In function, it is used to collect the remaining arguments in an array.
            eg. function sum(...numbers) {
                    return numbers.reduce((acc, num) => acc + num, 0);
                }
                console.log(sum(1, 2, 3, 4)); // 10
        -   Used to capture the remaining elements of an array into a new array.
            eg. const [first, second, ...rest] = [1, 2, 3, 4, 5];
                console.log(first); // 1
                console.log(second); // 2
                console.log(rest); // [3, 4, 5]

Array.foreach ;
    -   Use forEach when you want to iterate over the elements of an array and perform some operation without creating a new array.
    -   Both array.map and array.foreach does not mutate the original array.

Event Bubbling :
    -   Event bubbling is a phase in the event propagation of DOM in web browser.
        -   there are 3 phase 
            -   Capturing phase : event starts from root of document in DOM tree untill it reaches the target element.
            -   Targeting phase : when it reaches the target element, it triggers the event handler attached to that event.
            -   Bubbling phase : event bubbles up the tree triggering event handler on ancestors element.
            -   we take another attribute useCapture, if true, event trickling/capturing will happen and if undefined or
                false, event bubbling will happen.
            -   We can use event.stopPropagation() to stop the propagation.
                eg. <!DOCTYPE html>
                    <html lang="en">
                    <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Event Bubbling Example</title>
                    <style>
                        div {
                        padding: 20px;
                        border: 1px solid black;
                        margin: 5px;
                        }
                    </style>
                    </head>
                    <body>

                    <div id="outer">
                    <div id="middle">
                        <div id="inner">Click me!</div>
                    </div>
                    </div>

                    <script>
                    document.getElementById('outer').addEventListener('click', function (event) {
                        console.log('Outer div clicked');
                    });

                    document.getElementById('middle').addEventListener('click', function (event) {
                        console.log('Middle div clicked');
                    });

                    document.getElementById('inner').addEventListener('click', function (event) {
                        console.log('Inner div clicked');
                    });
                    </script>

                    </body>
                    </html>

Event Delegation :
    -   Instead of having multiple eventListeners attached to li, we just have one eventListeners attached to its parent div.
    -   And we route to the page using window.location.href = "/"+ e.target.id;
    -   because of event bubbling delegation is possible.

Call, apply & bind :
    -   Using call method we can do function borrowing. 
    -   We can borrow function from other objects.
    -   Every js object have access to this call function.
        eg. let printAddress = function(hometown){
                console.log("My name is" + this.name+"I live in " + this.country+"My hometown is" +this.hometown);
            }
            let user = {
                name : "Devesh",
                country :"India"
            }
            printAddress.call(user,"purnia")
    
    -   In apply method , we pass 2nd argument as arrayList.
        eg. printAddress.apply(user,["purnia"])

    -   bind will return us the function which can be invoked later.
        eg. letPrintMyName = printAddress.bind(name,"purnia")
            letPrintMyName();

Debouncing :
    -   It is used for better search experience. and is very performant.
    -   Generally used for performance optimization.
    -   it is done by limiting the rate of function call.
    -   if the difference between two keystrokes is 300 ms then we make a call
        eg. search, resize, buttonclick- machine gun



Throttling :
    -   Generally used for performance optimization.
    -   it is done by limiting the rate of function call.
    -   Only make an api call after certain interval of time.
        eg. search, resize , buttonclick- machine gun

    


