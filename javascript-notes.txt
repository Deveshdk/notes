//  Comparators $ Equality

    //  == only checks if the value is equal but === checks the value and the data type.
    //   ===  equal to
    //   !== not equal to
    //   > greater than
    //   < less than
    //  >= greater than or equal to
    //  <= less than or equal to
    //  && AND
    //  || OR 

Javascript is synchronous single-threaded language.
setTimeout, timer, local storage and document.getElementById or fetch() or console.log or addEventListener these are all web api and
these are all provided by browser in form of dom web api to the JS engine.
Javascript is loosely typed/weakly typed language. means it does not attaches its variable to a specific data type.
    means later the data type can be cahanged.

How Javascript Works :
    -   Whwnever we execute our code, a global execution context is created inside call stack with name anonymous.
    -   Execution context has 2 components. Memory and code.
    -   If any function is invoked, another execution context will be created with function name and will pushed into the call stack.
        And when execution of is completed, that execution context will popped out of the global context in call stack.
        And when all the execution is completed,global execution context will also be popped out and call stack will be empty.

Javascript has 2 phase.
    -   1st phase is Memory Execution : In this phase javascript scans the whole code and create a memory for all variable and function.
        Initially memory is created with undefined.
    -   2nd phase is Code Execution : In this phase execution happens.

Global space :
    -   Javascript creates 3 thing when execution starts.
    1. Global Execution context
    2. Global object i.e. window
    3. this
    At the start "this" will have the same value as window.
    eg. var x = 10;
        function b(){
            var a=5;
        }
        console.log(window.x);
        console.log(x);
        console.log(this.x);
        
        Output : 10,10,10 because window is in a global object, as well as this which has window in it.

Undefined vs Not-defined :
    -   Undefined is like a placeholder which is kept in a variable until in a code that variable is assigned to any value.
        But that variable should be present.
    -   Not defined means that variable is not present in the whole code. Means no memory creation for that variable.

Scope, scope & Lexical Environment :
    -   Lexical environment is created whenever an execution context is created.
    -   Lexical environment is the local memory and lexical environment of its parent.
    -   This whole chain of lexical enironment is called scope chain.
        eg. function a(){
                var b=10;
                c();
                function c(){
                    console.log(b);
                }
            }
            a();
        Output : 10;
                because c will be invoked, will try to log b, it will check its local memory first then if not found,
                it will check lexical environment of its parent(i.e. a).

Hoisting :
    -   Hoisting is a phenomenon in which you can access the variables or the functions before initializing it.
        eg1. console.log(x);
            getName();
            var x = 20;

            function getName () {
                console.log("Hello Javascript !");
            }
        Here we are accessing x and getname before initializing it.
        Explaination : In javascript before the code execution starts, memory creating is done for all variable and fn's.
            i.e memory for x and getName is already created.
            Now, for x it will print undefined if called before initialization.
            In case of getName, Output will be "Hello Javacript !" because you can access the function from anywhere in javascript
             until unless it's initialiazed in the whole code.

        eg2. var x = 20;
            function getName () {
                console.log("Hello Javascript !");
            }
            console.log(getName)

            In this case, memory is already created but the fn is not invoked yet so the output will be 
            ƒ getName () {
            console.log("Hello Javascript !");
            }   

        eg3.console.log(getName)
            var getName = () => {
            console.log("Hello Javascript !");
            } 
            In this case getName is an arrow fn , so it will behave as a variable.
            So during memory  creation phase undefined will be stored.

        eg4. var getName = function (){
            console.log("Hello Javascript !");
            }
            In this case as well, getName will behave like a variable.

let & const introduced in es6:
Temporal Dead Zone :
    -   let and const can be hoisted and memory is also created for let and const but its not in global space rather in script space.
    -   


Var vs let vs const:
    Scope:
        -   var | Function-scoped | If declared outside the function, it becomes global.
        -   let | Block-scoped | Visible only within a block {} it is declared in (like loops, if statements)
        -   const | Block-scoped | Same as let , visible only inside a block
    
    Redeclaration & Re-assignmemnt:
        -   var | Redeclare allowed | re-assignment allowed |eg. var a = 1; var a = 2;
        -   let | Redeclare not allowed | Re-assignment allowed | eg. let a = 1; a =2;
        -   const | Redeclare not allowed | Re-assignment not allowed | eg. const c = 1, // can't change c = 2;
            But objects and arrays declared as const can be be mutated.
                eg. const users = { name : 'Devesh' };
                    users.name = 'Sam';

    Hoisting:
        -      Keyword	    Hoisted?	Accessible Before Declaration?
                var	         ✅ Yes	     ✅ Undefined (not error)
                let	         ✅ Yes	     ❌ Temporal Dead Zone (Error)
                const	     ✅ Yes	     ❌ Temporal Dead Zone (Error)

    Best Practice: use const by default, use let in case of reassignmemnt & avoid var.

    Eg1. Looping 
        for (var i = 0; i < 3; i++) {
            document.body.innerHTML += `<button id="btn${i}">Button ${i}</button>`;
            
            document.getElementById(`btn${i}`).addEventListener("click", function() {
                console.log("Button index:", i);
            });
        }

        Output : if using var, output will be 3, 3, 3. because by the time button is clicked, loop is finished and i is 3(final value).
                 As, in case of var, one shared variable across loop iterations.

        Fix: use let. beacuse since let is a scoped variable, new variable for each iteration.

    Eg2. setTimeout when doing async call
        for( var i = 0; i < 3; i++){
            setTimeout(() => {
                console.log("index:", i);
            }, 1000);
        }
        Output: Index: 3,Index: 3,Index: 3

        Fix1: use let.
        Fix2. use closure.
            eg. for (var i = 0; i < 3; i++) {
                    (function(j) {
                        setTimeout(() => {
                        console.log("Index:", j);
                        }, 1000);
                    })(i);
                }
            Explaination: here immediately it captures the value of i and put it inside j.

Difference between == and ===
    -   Equality operator(==), it checks both operator and perform type correction if the types are different.
        -   Also called loose equality or abstract equality.
        Javascript will try to convert one or both operands to common type before comparison.
        eg. 3 == '3' // true 'string is converted to number'
            0 == false // true 'false is converted to 0'
            null == undefined // true

    -   Strict Equality Operator(===), compares both value and type.
        -   5 === '5' // false
            0 === false // false
            null === undefined // false



Block {}:
    -   Block is also kbnow as compound statement.
    -   A block is used to combine multiple js statement in one group.
    -   We combine mutiple statement in a block so can be used where javascript expects one statement.
    -   Each and every block has its own lexical scope. And if follows its own scope chain pattern.
Block Scope :
    -   What all variable and functions we can use inside a block.
        eg. {
                //compound statement
                var a=10;
                let b=20;
                const c=30;
                console.log(a);
                console.log(b);
                console.log(c);
            }
            console.log(a);
            console.log(b);
            console.log(c);
    -   let and const are block scope variable and once the block has been executed ,
        b and c will not be accessible while a was in global scope so "a" will be accessible.

Shadowing :
    -   If we have a same named variable outside the block, so it will shadow the variable.
    -   eg1. var a= 100;
            {
                //compound statement
                var a=10;
                let b=20;
                const c=30;
                console.log(a);
                console.log(b);
                console.log(c);
            }
        -   output will be : 10 20 30

        eg2. Output will be : 10 20 30 10  because both var a is pointing to the same global memory space.
            so "a" inside will shadow the outside the a variable.
            var a= 100;
            {
                //compound statement
                var a=10;
                let b=20;
                const c=30;
                console.log(a);
                console.log(b);
                console.log(c);
            }
            console.log(a);

        eg3. Output will be : 10 20 30 100 because now both "b" has different memory space. Inside b is inside block scope.
                outside b is in script space.
                Same happens in the case of const.
                And this happens in the case of function as well.
            let b= 100;
            {
                //compound statement
                var a=10;
                let b=20;
                const c=30;
                console.log(a);
                console.log(b);
                console.log(c);
            }
            console.log(b);

        eg4. Output will be 30 100
            const c= 100;
            function x(){
                //compound statement
                const c=30;
                console.log(c);
            }
            x();
            console.log(c);

    -   Illegal Shadowing :
        -   You cannot shadow var using let. but vice-versa is true.
            eg. let a=100;
                {
                    var a=10;
                } // Result in Syntax error.
                var a=100;
                {
                    let a=10;
                } // No error

Closure :
    -   Function which is bind together with its lexical parent forms a closure.
    -   Here b is bound with its local memory and variable of lexical parent. S0, it forms a closure.
        eg1. function c(){
                var a =10;
                function b(){
                    console.log(a);
                };
                b();
            };
            c();
    -   Function remembers its lexical scope even after returned.
    -   Here even if function b context is popped out after execution, but it still remembers its lexical scope and have memory.
        eg2. function c(){
                    var a =10;
                    function b(){
                        console.log(a);
                    };
                    return b;
                };
                var z = c();
                console.log(z);
                z();
        
        eg3.In this b will form 2 closure with c and s. Output: 10 900
        function s(){
                    var t=900;
                    function c(){
                        var a =10;
                        function b(){
                            console.log(a,t);
                        };
                        b();
                    };
                    c();
                };
                s();

    Uses of Closure :
        -   Module Design Pattern
        -   Currying
        -   Functions like once
        -   memoize
        -   maintaining state in async world
        -   setTimeouts
        -   Iterators

setTimeout & Closure :
    -   setTimeout takes a callback fn attaches the timer provided and stores in some other space and moves to the next line 
        and when that time has elapsed then js will put that fn in the call stack and executes it.
        eg. function x(){
                var i=10;
                setTimeout(function(){
                    console.log(i);
                },3000);
                console.log("Hello");
            }
            x(); /// Output : Hello 10

Counter with closure :
    -   Refer to js file.
    Disadvantage of Closure :
        -   There could be over consumption of memory because those variable are not garbage collected till the program expires.
        -   And if not handeled properly, there could be memory leak.
        Garbage Collector :
            -   It is like a program , whenever there is some unused variables which is not needed, it ceases/frees up the memory.
                since javascript is high level programming language. It is done by the JS engine.

Functions :
    -   Main Difference between function statement and function expression is hoisting.
    -   Function Statement :
        -   function a(){
                console.log(a);
            }
    -   Function Expression :
        -   var b = function(){
                console.log("b called");
            }
    -   Function Declaration :
        -   Function Declaration is also Function Statement.
    -   Anonymous Function :
        -   Function without a name is called anonymous function.
        -   Anonymous fn does not have its own identity.
        -   function () {

            }
    -   Named Function Declaration :
        -   var c = function abc(){
                console.log("b called");
            }

            abc(); // this will result in error because this fn abc was not created in global scope.
            It was created as a local variable.
    -   Parameters & Arguments :
        -    var b = function(param1, param2){    // param 1 and param2 is a parameter
                            console.log("b called");
                        }
            b(1,2); // 1 and 2 is an argument

    -   First Class Functions :
        -   The ability to use functions as values and can pass a fn inside a function or return a fn from a fn is called 
            first class function or first class citizens.
            eg. var a = function b(param1){
                    return (
                        console.log(b)
                    )
                }
                a(function(){

                })
    -   Arrow Functions introduced in es6:
        -   

Callback Function :
    -   When you pass a function inside another fn. You give the responsibility of calling a fn to another fn to call it some other time.
        This is callback fn.
    -   Using callback we can do the async task in javascript which is a single threded synchronous language.
        eg. setTimeout(function(){
                console.log("timer");
            },5000);

            function x(y){
                console.log("x");
                y();
            }
            x(function y(){
                console.log("y");
            })
    
    -   Event Listeners :
            eg. function attachEventListeners(){
                    let count = 0;
                    document.getElementById("clickMe").addEventListener("click",()=>{
                        console.log("Button Clicked" , ++count);
                    })
                }
                attachEventListeners();
        
        -   Garbage Collection & Remove EventListeners :
            -   EventListenerds are heavy and take memory because it forms a closure. And even if call stack is empty,
                program will not free up the extra memory. In order to do that we should remove our eventListeners.
                So, all this variables that was in the closure will be garbage collected.

Event loop :
    -   Event loop is a mechanism that allows javascript to handle asynchronous operations without blocking the main thread.
    -   The purpose of event loop is to constantly monitor the call stack, microtask queue and the callback queue 
        if there is any callback fn present and 
        then it will create a executioj context for that callback fn and puts that callback fn inside the callstack.
        Refer to Callback.js

        CallStack --> WebApi's --after done --> Task Queues(Macro-tasks | Micro-tasks) --Event loop --> Moves taks to the call stack 

    -   Microtask Queue :
        -   Microtask queue has higher priority.
        -   First microtask queue will execute and then callback queue will execute.
        -   All the callback fn that comes with promises or mutation server will go in microtask queue.

        Eg. console.log("Start");
            setTimeout(() => console.log("Timeout"), 0);
            console.log("End");

            Execution:
                1. console.log("Start") -> runs immediately
                2. setTImeout -> sent to web api, wait for 0ms -> goes to macro-tasks queue
                3. console.log("End") -> runs immediately
                4. Stack is now empty -> Event loop pulls from macro-task queue -> logs Timeout
            Output: Start, End, Timeout

        Eg2. promise vs setTimeout
                console.log("Start");
                setTimeout(() => console.log("Timeout"), 0);
                Promise.resolve().then(() => console.log("Promise"));
                console.log("End");

            Execution: 
                1. console.log("Start") -> runs immediately
                2. setTImeout -> sent to web api, wait for 0ms -> goes to macro-tasks queue
                3. promise -> goes to microtask queue
                3. console.log("End") -> runs immediately
                4. Stack is now empty -> runs microtask forst -> Promise -> Then macro task -> Timeout

            Output: Start, ENd, Promise, Timeout

Trust Issue with setTimeout :
    -   

Higher Order function :
    -   A function that takes a fn as an argument and returns a fn.
        eg. const radius = [1,2,3,4,5];

            const area = function (radius){
                return 2*Math.PI*radius*radius;
            }

            const calculate = function (radius,logic){
                const output = [];
                for(let i=0;i<radius.length;i++){
                    output.push(logic(radius[1]));
                }
                return output;
            }

            console.log(calculate(radius,area));

Map filter reduce :
    -   These functions is used to transform an array.
    Purpose: Transform each element of an array → returns a new array of the same length.
    Does not mutate the original array.
    Use case: Rendering lists in React (.map() to return JSX)    .

    Map :
        -   Map fn is used to transform an array and return a transformed array. or it is used to map each values in an array.
        -   const arr = [1,2,3,4,5];
            const output = arr.map(double);

            function double(x){
                return x*2;
            }

            function binary(x){
                return x.toString(2);
            }

    Filter :
        -   Filter fn is used to filter an array based on the condition.
        -   const arr = [3,5,7,9];
            const output = arr.filter(isOdd);

            function isOdd(x){
                return x%2;
            }
            function isEven(x){
                return x%2==0;
            }

    Reduce :
        -   Reduce fn takes all the values of an array and returns a single value out of them.
        -   It takes 2 parameter. one is a function which take acc and current, and other is the initialized value of acc.
        -   accumulator is like let count =0, or let sum =0; which will be updated or incremented ater iteraion. 
        -   accumilator must be initialiazed 
        -   const arr = [1,2,3,4,5];
            const sum = arr.reduce(function(acc,curr)=>{
                acc =acc + curr;
                return acc;
            },0);

        -   const findMax = arr.reduce(function(max,curr)=>{
                if(curr>max){
                    max=curr;
                }
                return max;
            },0);

        -   const users=[
            {fname:"Devesh" , lname : "kumar" , age :25},
            {fname : "mona", lname:"kaushiki",age:26},
            {fname:"motu", lname:"chumu", age:26},
            ]
            
            //find list of full name
            const output = users.map((x)=> x.fname +" "+ x.lanme);

            // how may users are with same age eg. {25:1,26:2}
            const output = users.reduce(function(acc,curr)=>{
                if(acc[curr.age]){
                    acc[curr.age] = ++ acc[curr.age];
                }
                else{
                    acc[curr.age]=1;
                }
                return acc;
            },{})

            // first name of all people whose age is <30
            aont output = users.filter(x=> x.age<30).map(x=> x.fname);


| Method   | Input → Output                              | Returns                        | Typical Use Case    |
| -------- | ------------------------------------------- | ------------------------------ | ------------------- |
| `map`    | Each element → transformed element          | New array (same size)          | Transform data      |
| `filter` | Each element → condition check (true/false) | New array (smaller/equal size) | Select subset       |
| `reduce` | Each element → combined into single result  | Single value (any type)        | Aggregate / Compute |


Callback hell or Pyramid of Doom:
    -   One callback inside another callback inside callback or a lot of nested callback.
Inversion of Control :
    -   We lose control of our program because we passed that callback fn into another fn and now we have given the control of 
        that fn to some other fn. And now we don't know whether that fn will ever execute our callback or not.

Promise :
    -   Promise is an object that represent an eventual completion or failure of an asynchronous event.
    -   PromiseState represents the current state of a promise.Promise has 3 state. Initially it is in pending state.
        Pending, Fulfilled & Rejected.
    -   Promise can only be resolved once and promise obejcts are immutable too so we can just pass it here n there in our code.
    -   We can attach a handler/callbackfn with .then
    -   So promise resolves our concern over Inversion of control.
    -   eg. const GITHUB_API = "https://github.com/Deveshdk?tab=repositories";
            const user= fetch(GITHUB_API);
            console.log(user);
            // now we attach a callback fn
            user.then(function(data){
            })
            -   And we attach n number of callback functions to our promise using .then
            -   This resolves our concern of callback hell using promise chaining.
                eg. createOrder(cart)
                    .then(function(orderId){
                        return proceedToPayment(orderId)
                    })
                    .then(function(paymentInfo){
                        return orderSummary(paymentInfo)
                    })
                    .then(function(paymentInfo) {
                        returnwalletUpdate(paymentInfo)
                    });
    -   How to create a promise and promise chaining with example. eg. createPromise.js

Promise Api :
    -   Promise.all() / fail fast:
        -   It takes an array of promise. eg. promise.all = [p1,p2,p3]
        -   It will make 3 parallel api call.
        -   Case1 : If all gets success.
                Output : [val1, val2, val3] and output will wait for all of them to finish(time taken).
            Case2 :  If any of these promise get rejected.
                Output : As soon as any of these promise gets rejected, promise.all will throw an error.(immediately)
                        And the output will give the same error as the rejected one.
                        It will not even wait other promise to be resolved or rejected.
                        You cannot cancel the promise in between.

    -   Promise.allSettled() :
        -   Case 1 : If all gets resolved. 
                Output : [val1,val2,val3] and output will wait for all of them to finish(time taken). same as promise.all in success.
            Case 2 : If p2 get rejected. It will still wait for all promise to get settled/completed.
                Output : [val1,err2,val3] The output will always be an array and with the same number of promises.
    
    -   Promise.race() :
        -   It will give you the value of 1st settled promise. 
        -   Output will be the result of 1st settled promise either value if resolved or error if rejected.
    
    -   Promise.any() :
        -   It will wait for 1st successful/fulfilled/resolved promise.
        -   If all the promises gets rejected, Output will be aggregated error. [err1,err2,err3]
        -   THis is how we catch/handle an Aggregate error. eg. console.log(err.errors);

Async/ await :
    -   Async will always returns a promise. but if you return a value, then the function will wrap that value in a promise and 
        then return a promise.
    -   Async and await is used to handle promises.
    -   In async / await , we dont have to do the promise chaining and it is more readable.
    -   Await is keyword that can only be used inside an async fn and it resolves the promise. you always write it infornt of a promise.
        eg. const p1 = new Promise(function(resolve,reject){
                setTimeout(()=>{
                    resolve("Promise resolved value");
                },5000);
            })

            const p2 = new Promise(function(resolve,reject){
                setTimeout(()=>{
                    resolve("Promise resolved value");
                },10000);
            })

            // after async await
            async function handlePromise(){
                console.log("hello world");
                const val1 = await p1;
                console.log("Hello1");
                console.log(val1);
                const val2 = await p2;
                console.log("Hello2");
                console.log(val2);
            }
            handlePromise();
            -   When the execution starts, handlePromise will be added in the call stack , and when it will find await p1
                handlePromise will move out of the call stack and will not block the main thread.
                now once p1 is resolved after 5 sec then handlePromise will again be added in the call stack and
                it will start it's execution 
                from where it left and then again when it will find await p2 ,
                handlePromise will again suspend the execution and move out of 
                the call stack and when p2 is resolved , then handlePromnise will again be added in the call stack and will start its 
                execution from where it left.

    Error Handling :
        -   using try and catch.

Function Curring :
    -   Currying is a functional programming concept where a function with multiple arguments is transformed into a series of functions,
        each taking a single argument.
        It allows you to create more specialized functions by partially applying arguments to a function, resulting in a new function.
    -   Currying can be achieved by using bind and by using closure.
    -   bind is used to make a copy of a function by passing partial arguments to the function.
        eg. function multiply(x,y){
                console.log( x*y);
            }
            let multiplyByTwo = multiply.bind(this,2);
            multiplyByTwo(3); or we can pass it different way as well . in below

            let multiplyByTwo = multiply.bind(this,2,3);
            multiplyByTwo(); or we can pass it in another way as well. in below

            let multiplyByTwo = multiply.bind(this);
            multiplyByTwo(2,3);

        eg2. Using closure
            function multiply(x){
                return function(y){
                    console.log(x*y);
                }
            }
            let multiplyByThree = multiply(10);
            multiplyByThree(2);


React Fragment <></> or <React.Fragment></React.Fragment>: 

Prototype & prototypal inheritence :
    -   Whenever we create any javascript object, functions or variable , JS put some hidden properties and methods into an object
        and attaches it to our object. 
    -   Prototype is an object that attaches to our object with some hidden properties and methods.
    -   
        let arr = ["dev","mona"]
        function fun(){

        }
    -   In order to see that object that JS attaches we can simply do like f.__proto__ or arr.__proto__
    -   arr.__proto__ is Array.Prototype => arr.__proto__.__proto__ is Object.prototye => arr.__proto__.__proto__.__proto__ is null.
    -   fun.__proto__ is Function.prototype => fun.__proto__.__proto__ is Object.prototype ==>fun.__proto__.__proto__.__proto__ is null.
    -   This is called prototype chain.

    Protoypal inheritence :
    -   If we attach any object1 to another object2 prototype, we will be able to use object1 properties.
    -   In case of function if we bind any fn to Function.protype, we will be able to use that fn in all other fn using fn.__proto__.methodName
        -   eg. let object = {
                    name : "Devesh",
                    age : 28,
                    city: "Purnia",
                    getIntro: function(){
                        console.log("My name is"+ this.name + "And my age is " + this.age);
                    }
                }

                let object2 = {
                    name : "Mona",
                    age :29
                }
                object2.__proto__ = object;
                console.log("My name is "+ object2.name + " and i am from "+ object2.city);

                Function.prototype.mybind = function(){
                    console.log("I am Heman!!");
                }

                function fun(){
                    fun.__proto__.mybind();
                }

Deep copy of an Object :
    -   Making a deep copy of an object involves creating a new object with the same structure and values as the original object,
        while ensuring that nested objects and arrays are also copied rather than referenced.

        Approach 1 : this does not work with object that contains fn or undefined or symbols.
            const originalObject = { a: 1, b: { c: 2 } };
            const deepCopy = JSON.parse(JSON.stringify(originalObject));
            console.log(deepCopy);
        
        Approach 2 : Using a deep copy fn.
            function deepCopy(obj) {
                if (obj === null || typeof obj !== 'object') {
                    return obj;
                }

                if (Array.isArray(obj)) {
                    return obj.map(deepCopy);
                }

                const copy = {};
                for (const key in obj) {
                    if (obj.hasOwnProperty(key)) {
                    copy[key] = deepCopy(obj[key]);
                    }
                }

                return copy;
            }

            const originalObject = { a: 1, b: { c: 2 } };
            const deepCopy = deepCopy(originalObject);
            console.log(deepCopy);

        Apporach 3 : Using library lodash and .cloneDeep method
            const _ = require('lodash');
            const originalObject = { a: 1, b: { c: 2 } };
            const deepCopy = _.cloneDeep(originalObject);
            console.log(deepCopy);

Copy of an Object :
    -   We can make a copy of an object in 2 ways :
        -   Shallow copy
            -   Using Spread operator (...) :
                eg. const originalObject = { a: 1, b: { c: 2 } };
                    const shallowCopy = { ...originalObject };
            -   Using Object.assign() :
                eg. const originalObject = { a: 1, b: { c: 2 } };
                    const shallowCopy = Object.assign({}, originalObject);
        -   Deep copy using deep function or library or JSON.parse & JSON.stringify.

Merge to an array ;
    -   Concatenation (shallow copy) : It will create a new array.
        eg. array1.concat(array2);
    -   Spread Operator (shallow copy) : It will create new array.
        eg. const mergedArray = [...array1, ...array2];
    
    -   Array.push() : Mutates the original array.
        eg. array1.push(...array2);
    -   Array.unshift() : Mutates the original array. It adds elements to the beginning of an array.
        eg. array2.unshift(...array1);

Pure fn vs Impure fn :
    -   Pure fn :
        eg. function add(a, b) {
                return a + b;
            }
        -   with same imput, always same output.
        -   Immutable data
        -   Does not rely on external state.
        -   Does not modify the imput parameter.
        -   Does not modify variable outside its scope.
        -   Behaviour is predictabe and isolated , so straightforward to test.
        -   No hidden dependency.
    
    -   Impure fn :
        eg. let total = 0;
            function impureAdd(a) {
            total += a;
            return total;
            }
        -   relies on external state and modifies it.

Spread and Rest Operator :
    -   Both denoted by (...)
    -   Spread Operator :
        -   Used to make a shallow copy of an array or concatenate array.
        -   Used to make a shallow copy of an object or to merge an object.
    -   Rest Operator :
        -   In function, it is used to collect the remaining arguments in an array.
            eg. function sum(...numbers) {
                    return numbers.reduce((acc, num) => acc + num, 0);
                }
                console.log(sum(1, 2, 3, 4)); // 10
        -   Used to capture the remaining elements of an array into a new array.
            eg. const [first, second, ...rest] = [1, 2, 3, 4, 5];
                console.log(first); // 1
                console.log(second); // 2
                console.log(rest); // [3, 4, 5]

Array.foreach ;
    -   Use forEach when you want to iterate over the elements of an array and perform some operation without creating a new array.
    -   Both array.map and array.foreach does not mutate the original array.

Event Bubbling :
    -   Event bubbling is a phase in the event propagation of DOM in web browser.
        -   there are 3 phase 
            -   Capturing phase : event starts from root of document in DOM tree untill it reaches the target element.
            -   Targeting phase : when it reaches the target element, it triggers the event handler attached to that event.
            -   Bubbling phase : event bubbles up the tree triggering event handler on ancestors element.
            -   we take another attribute useCapture, if true, event trickling/capturing will happen and if undefined or
                false, event bubbling will happen.
            -   We can use event.stopPropagation() to stop the propagation.
                eg. <!DOCTYPE html>
                    <html lang="en">
                    <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Event Bubbling Example</title>
                    <style>
                        div {
                        padding: 20px;
                        border: 1px solid black;
                        margin: 5px;
                        }
                    </style>
                    </head>
                    <body>

                    <div id="outer">
                    <div id="middle">
                        <div id="inner">Click me!</div>
                    </div>
                    </div>

                    <script>
                    document.getElementById('outer').addEventListener('click', function (event) {
                        console.log('Outer div clicked');
                    });

                    document.getElementById('middle').addEventListener('click', function (event) {
                        console.log('Middle div clicked');
                    });

                    document.getElementById('inner').addEventListener('click', function (event) {
                        console.log('Inner div clicked');
                    });
                    </script>

                    </body>
                    </html>

Event Delegation :
    -   Instead of having multiple eventListeners attached to li, we just have one eventListeners attached to its parent div.
    -   And we route to the page using window.location.href = "/"+ e.target.id;
    -   because of event bubbling delegation is possible.

Call, apply & bind :
    -   Using call method we can do function borrowing. 
    -   We can borrow function from other objects.
    -   Every js object have access to this call function.
        eg. let printAddress = function(hometown){
                console.log("My name is" + this.name+"I live in " + this.country+"My hometown is" +this.hometown);
            }
            let user = {
                name : "Devesh",
                country :"India"
            }
            printAddress.call(user,"purnia")
    
    -   In apply method , we pass 2nd argument as arrayList.
        eg. printAddress.apply(user,["purnia"])

    -   bind will return us the function which can be invoked later.
        eg. letPrintMyName = printAddress.bind(name,"purnia")
            letPrintMyName();

Debouncing :
    -   Debounced function delays execution untill after a certain 'qient time' has passed since the last event.
    -   If the event happens again before the delay, timer resets.
    -   It is used for better search experience. and is very performant.
    -   Generally used for performance optimization.
    -   it is done by limiting the rate of function call.
    -   if the difference between two keystrokes is 300 ms then we make a call

    Explaination:
        -   if you type in search , and on every key press api call is made. then by debouncing,
            it will wait for the user to stop typing before making API request.
        -   Same happens in case of resizing.
        eg. search, resize, buttonclick- machine gun

        function debounce(fn, delay) {
            let timer;
            return function(...args) {
                clearTimeout(timer);
                timer = setTimeout(() => fn.apply(this, args), delay);
            };
            }

            // Usage:
            const handleSearch = debounce((query) => {
            console.log("Searching for:", query);
            }, 500);

            input.addEventListener("input", (e) => handleSearch(e.target.value));

            🧠 Behavior:
                User types “h” → timer starts (500ms)
                User types “he” before 500ms → timer resets
                User stops typing → after 500ms, function executes ✅
                ✅ Result: function runs only once after user stops typing.

Throttling :
    -   Throttle fn make sure that it executes no more than once in a given time window.
    -   Generally used for performance optimization.
    -   it is done by limiting the rate of function call.
    -   Only make an api call after certain interval of time.
        eg. scroll events, mouse-move tracking.

        function throttle(fn, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                fn.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
                }
            };
            }

            // Usage:
            const handleScroll = throttle(() => {
            console.log("Scroll event:", window.scrollY);
            }, 500);

            window.addEventListener("scroll", handleScroll);

            🧠 Behavior:
                Scroll event fires many times per second
                Function runs immediately once ✅
                Then ignores events for 500ms
                Runs again after 500ms ✅
                ✅ Result: function runs periodically, not continuously.


What is memoization and how do you implement it?
    -   We use memoization for optimizing our application.

    3 ways to optimize.
        1. React.Memo: Component level optimization
            -   Wraps a functional component to prevent re-renders if props haven't changed.

                const Child = React.memo(({ count }) => {
                    console.log("Child rendered");
                    return <div>Count: {count}</div>;
                });

                function Parent() {
                    const [count, setCount] = useState(0);
                    const [text, setText] = useState("");

                    return (
                        <>
                        <Child count={count} /> {/* ✅ Only re-renders when `count` changes */}
                        <input value={text} onChange={e => setText(e.target.value)} />
                        <button onClick={() => setCount(count + 1)}>+</button>
                        </>
                    );
                }

                Without react.memo, everytime you type in the input, the parent re-renders -> child re-renders too.
                With react.memo, child skips re-render, if props are the same.

        2. useMemo: Value-level optimization
            -   catches the result of a computations so it's not recalculated on every render. 
                function ExpensiveComponent({ num }) {
                    const expensiveValue = useMemo(() => {
                        console.log("Calculating...");
                        return num * 1000; // imagine something heavy
                    }, [num]);

                    return <div>Value: {expensiveValue}</div>;
                }

                🧠 Without useMemo: calculation runs every render
                ✅ With useMemo: runs only when num changes

        3. useCallback: Function-level optimization
            -   Returns a memoized function reference, so it dosen't get recreated on every render.
                const Child = React.memo(({ onClick }) => {
                    console.log("Child rendered");
                    return <button onClick={onClick}>Click</button>;
                    });

                    function Parent() {
                    const [count, setCount] = useState(0);

                    const handleClick = useCallback(() => {
                        console.log("Clicked");
                    }, []); // ✅ same reference across renders

                    return (
                        <>
                        <Child onClick={handleClick} />
                        <button onClick={() => setCount(c => c + 1)}>Increment</button>
                        </>
                    );
                }


What is the difference between synchronous and asynchronous programming?

    | Feature          | **Synchronous**      | **Asynchronous**                     |
    | ---------------- | -------------------- | ------------------------------------ |
    | Execution        | Line by line         | Non-blocking                         |
    | Next line waits? | ✅ Yes                | ❌ No                                |
    | Speed            | Slower               | Faster (non-blocking)                |
    | Example          | `console.log`, loops | `setTimeout`, `fetch`, `async/await` |
    | Use cases        | Simple tasks         | Network requests, timers, I/O        |


What are generators in JavaScript?
    -   Geenrators are a special type of functions that can be paused and resumed later.
    -   The * (asterisk) marks it as a generator.
    -   Executes code until the next yield.
    -   Unlike regular functions that run from start to finish, a generator can yield values one by one, and resume from where it left off using the yield keyword.
    eg. used in redux-saga.
        import { call, put, takeEvery } from 'redux-saga/effects';
        import { fetchDataApi } from './api';
        import { fetchDataSuccess, fetchDataFailure } from './actions';

        // Worker saga: does the async task
        function* fetchDataSaga(action) {
        try {
            const data = yield call(fetchDataApi, action.payload); // call API
            yield put(fetchDataSuccess(data));                     // dispatch success action
        } catch (error) {
            yield put(fetchDataFailure(error.message));           // dispatch failure action
        }
        }

        // Watcher saga: watches for specific actions
        function* watchFetchData() {
        yield takeEvery('FETCH_DATA_REQUEST', fetchDataSaga);
        }

        // Root saga
        export default function* rootSaga() {
        yield watchFetchData();
        }

    -   There are few redux-saga effects ( like. call, put, takeEvery, takeLatest etc)

            | Helper                         | Usage                                        |
            | ------------------------------ | -------------------------------------------- |
            | `call(fn, ...args)`            | Calls a function (usually API)               |
            | `put(action)`                  | Dispatches a Redux action                    |
            | `takeEvery(actionType, saga)`  | Watches for actions and runs saga every time |
            | `takeLatest(actionType, saga)` | Runs saga for latest action only             |
            | `delay(ms)`                    | Pauses saga for a given time                 |

        🧠 Why Use Generators?
            1. Lazy Iteration (produce values one at a time)
            2. Infinite sequences
            3. Custom iterators
            4. Async control flow (before async/await existed)
            5. Pausing execution of complex processes


What is event delegation?
    -   Event Delegation is a technique where you attach a single event listener to a parent element instead of attaching listeners to multiple child elements.

What is module pattern in JavaScript? How does ES6 module system work?
    -   The Module Pattern is a way to structure your code into self-contained units (modules) that:
            -   Encapsulate private data and methods
            -   Expose only what’s necessary (public API)
            -   It helps prevent global namespace pollution and keeps code maintainable and reusable.


    | Feature             | Module Pattern                | Modern ES6 Modules                   |
    | ------------------- | ----------------------------- | ------------------------------------ |
    | Encapsulation       | ✅ Private variables           | ✅ Private by default in module scope |
    | Public API          | ✅ Exposed via returned object | ✅ Exposed via `export`               |
    | Namespace pollution | ❌ Prevents globals            | ❌ Prevents globals                   |
    | Syntax              | IIFE, closures                | `import` / `export`                  |


Explain WeakMap and WeakSet and when you’d use them.

What are Symbols in JavaScript?
    -   Symbols are mainly used when you need truly unique identifiers or want to avoid property name collisions in objects.
        const sym1 = Symbol();
        const sym2 = Symbol("id");

        console.log(sym1 === sym2); // false

        no two symbols are same.

What are keys in react lists and why are they important?
    -   A key is a special string or number that uniquely identifies an element in a list.

        const fruits = ["Apple", "Banana", "Cherry"];

        function FruitList() {
        return (
            <ul>
            {fruits.map((fruit, index) => (
                <li key={index}>{fruit}</li>
            ))}
            </ul>
        );
        }

        Good key: uniques & stable
        Bad key: index(could be problem if list changes dynamically)

        🧠 Rules for Keys
                -   Must be unique among siblings.
                -   Don’t use array index if list can change dynamically.
                -   Should be stable (don’t generate new key every render).

        Why are they important?
            Efficient Updates
                React uses Virtual DOM diffing to update only the changed elements.
                Keys help React match old and new elements.
                Without keys, React may re-render unnecessarily or reuse wrong elements.

            Preserve Component State
                If a list item is a component with state, the key ensures state stays with the right element.

            Prevent Bugs
                Without unique keys, UI may behave unpredictably when adding/removing items.

this keyword : 
    -   

Set interval :
    -   

Arrow fn vs regular fn :
    -   

Create a user token :
    -   